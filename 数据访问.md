# 1. 事务管理

# 1.1  Spring框架事务管理介绍

全面的事务支持是使用Spring框架的最有说服力的理由之一。 Spring框架为事务管理提供了统一的抽象，具有以下好处：

- 跨越不同事务API（如Java事务API（JTA），JDBC，Hibernate和Java持久性API（JPA））的统一编程模型。
- 支持 [declarative transaction management](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction-declarative)
- 支持的[programmatic](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction-programmatic)事务管理API比复杂事务API（如JTA）要简单。
- 与Spring的数据访问抽象完美整合。

以下部分描述了Spring框架的事务增值和技术。 （s本章还包括讨论最佳实践，应用程序服务器集成和常见问题的解决方案。）

- [Advantages of the Spring Framework’s transaction support model](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction-motivation) 描述了为什么要使用Spring框架的事务抽象而不是EJB容器管理的事务（CMT），或者选择通过Hibernate等专有API驱动本地事务。
- [Understanding the Spring Framework transaction abstraction](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction-strategies)概述了核心类，并介绍了如何从各种来源配置和获取DataSource实例。
- [Synchronizing resources with transactions ](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#tx-resource-synchronization)描述应用程序代码如何确保正确地创建，重用和清理资源。
- [Declarative transaction management](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction-declarative)描述了对声明式事务管理的支持。
- [Programmatic transaction management](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction-programmatic)包括对编程式（即明确编码的）事务管理的支持。
- [Transaction bound event](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction-event) 描述了如何在事务中使用应用程序事件。

## 1.2  Spring框架的事务支持模型的优点

传统上，Java EE开发人员对事务管理只有两种选择：全局或本地事务，两者都有很大的局限性。接下来的两节将回顾全局和本地事务管理，然后讨论Spring框架的事务管理支持如何解决全局和本地事务模型的局限性。

### 1.2.1 全局事务

全局事务使您能够处理多个事务资源，通常是关系数据库和消息队列。应用程序服务器通过JTA管理全局事务，这是一个繁琐的API使用（部分归因于它的异常模型）。此外，JTA UserTransaction通常需要来自JNDI，这意味着您还需要使用JNDI才能使用JTA。很明显，全局事务的使用将限制应用程序代码的任何潜在的重用，因为JTA通常只在应用程序服务器环境中可用。

以前，使用全局事务的首选方式是通过EJB CMT（容器管理事务）：CMT是一种声明式事务管理（区别于编程式事务管理）。 EJB CMT消除了与事务相关的JNDI查找的需要，当然，使用EJB本身也需要使用JNDI。它消除了大部分但不是全部，仍需要编写Java代码来控制事务。重大的缺点是CMT与JTA和应用程序服务器环境相关联。此外，只有选择在EJB中实现业务逻辑时，或者至少在事务性EJB Facade的基础上才能用事务。一般来说，EJB的负面影响非常大，所以这不是一个有吸引力的命题，特别是在面向声明式事务管理的引人注目的选择方面。

### 1.2.2 本地事务

本地事务是特定于资源的，例如与JDBC connection关联的本地事务。本地事务可能更容易使用，但有明显的缺点：它们不能在多个事务资源上工作。例如，使用JDBC连接管理事务的代码无法在全局JTA事务中运行。由于应用服务器不涉及事务管理，因此无法保证跨多个资源的正确性。 （值得注意的是，大多数应用程序使用单个事务资源。）另一个缺点是本地事务对编程模型是侵入式的。

### 1.2.3  Spring框架的一致编程模型

Spring解决了全局和本地事务的缺点。它使应用程序开发人员能够在任何环境中使用一致的编程模型。您只需编写一次代码，并且可以从不同环境中的不同事务管理策略中受益。 Spring Framework提供了声明式和编程式事务管理。大多数用户更喜欢声明式事务管理，这在大多数情况下是推荐的。

通过编程式事务管理，开发人员可以使用Spring Framework事务的抽象类，它可以在任何基础事务基础结构上运行。使用首选的声明式事务模型，开发人员通常会写很少或不写与事务管理相关的代码，因此不依赖于Spring Framework事务API或任何其他事务API。

```
                                               你需要一个应用程序服务器进行事务管理吗？
Spring框架的事务管理支持改变了传统的规则，即企业Java应用何时需要应用服务器。

特别是，您不需要应用程序服务器只是通过EJB进行声明式事务。事实上，即使你的应用程序服务器具有强大的JTA功能，你也可以决定使用Spring框架的声明性事务提供比EJB CMT更多的功能和更高效的编程模型。

通常情况下，只有当您的应用程序需要处理跨多个资源的事务时，您才需要应用程序服务器的JTA功能，这对于许多应用程序来说并不是必需的。而许多高端应用程序使用单个高度可伸缩的数据库（如Oracle RAC），所以也不需要跨多个资源的事务。独立事务管理器，如Atomikos Transactions和JOTM是其他事务管理的方式。当然，您可能还需要其他应用程序服务器功能，例如Java消息服务（JMS）和Java EE连接器体系结构（JCA）。
```

## 1.3 理解Spring Framework事务抽象

Spring事务抽象的关键是事务策略的概念。事务策略由org.springframework.transaction.PlatformTransactionManager接口定义：

```java
public interface PlatformTransactionManager {

    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;

    void commit(TransactionStatus status) throws TransactionException;

    void rollback(TransactionStatus status) throws TransactionException;
}
```

这个接口主要是一个服务提供者接口（SPI），虽然它也可以在应用程序代码中以编程方式使用。由于PlatformTransactionManager是一个接口，因此可以根据需要轻松进行mock或存根(stubbed)。它不受诸如JNDI之类的查找策略的束缚。 PlatformTransactionManager实现可以像Spring Framework IoC容器中的任何其他对象（或bean）一样定义。单就这个好处而言，即使在使用JTA的时候，Spring Framework事务也是一个有价值的抽象。事务代码可以比直接使用JTA更容易测试。

按照Spring的理念，任何PlatformTransactionManager接口的方法都可以抛出的TransactionException没有被检查（也就是说，它扩展了java.lang.RuntimeException类）。因为事务基础设施故障几乎总是致命的。在应用程序代码实际上可以从事务故障中恢复的罕见情况下，应用程序开发人员仍然可以选择捕获和处理TransactionException。重点是开发者没有被强制这样做。

getTransaction（..）方法根据TransactionDefinition参数返回一个TransactionStatus对象。返回的TransactionStatus可能代表一个新的事务，或者如果当前调用堆栈中存在匹配的事务，则可以代表一个已经存在的事务。后一种情况的含义是，与Java EE事务上下文一样，TransactionStatus与一个执行线程相关联。

TransactionDefinition接口指定以下内容：

- 隔离：这个事务与其他事务的分离程度。例如，这个事务是否可以看到来自其他事务的未提交的写入；
- 传播：通常，在事务范围内执行的所有代码都将在该事务中运行。但是，如果在事务上下文已经存在的情况下执行事务方法，则可以选择指定行为。例如，代码可以继续在现有的事务中运行（常见的情况）。或者现有事务可以被暂停并创建新的事务。 Spring提供了EJB CMT所熟悉的所有事务传播选项。要了解Spring中事务传播的语义，请参阅[Transaction propagation](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#tx-propagation)。
- 超时：在超时之前该事务运行多久，并由基础事务基础结构自动回滚。
- 只读状态：当您的代码只读取但不修改数据时，可以使用只读事务。在某些情况下，只读事务可以是一个有用的优化，例如当您使用Hibernate时。

这些设置反映了标准的事务概念。如有必要，请参阅讨论事务隔离级别和其他核心事务概念的资源。理解这些概念对于使用Spring框架或任何事务管理解决方案都是至关重要的。

TransactionStatus接口为事务代码提供了一种简单的方法来控制事务执行和查询事务状态。这些概念应该很熟悉，因为它们对于所有的事务处理API都是通用的：

```java
public interface TransactionStatus extends SavepointManager {

    boolean isNewTransaction();

    boolean hasSavepoint();

    void setRollbackOnly();

    boolean isRollbackOnly();

    void flush();

    boolean isCompleted();

}
```

无论您选择使用Spring中声明式或编程式事务管理，定义正确的PlatformTransactionManager实现是绝对必要的。你通常通过依赖注入来定义这个实现。

PlatformTransactionManager实现通常需要知道它们的工作环境：JDBC，JTA，Hibernate等等。以下示例显示如何定义本地PlatformTransactionManager实现。 （这个例子使用普通的JDBC。）

你定义一个JDBC数据源

```xml
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="${jdbc.driverClassName}" />
    <property name="url" value="${jdbc.url}" />
    <property name="username" value="${jdbc.username}" />
    <property name="password" value="${jdbc.password}" />
</bean>
```

相关的PlatformTransactionManager bean定义将会有一个对DataSource定义的引用。它看起来像这样：

```xml
<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>
```

如果您在Java EE容器中使用JTA，那么您将通过JNDI获得的容器DataSource与Spring的JtaTransactionManager结合使用。下面是JTA和JNDI查找版本的例子：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jee
        http://www.springframework.org/schema/jee/spring-jee.xsd">

    <jee:jndi-lookup id="dataSource" jndi-name="jdbc/jpetstore"/>

    <bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" />

    <!-- other <bean/> definitions here -->

</beans>
```

JtaTransactionManager不需要了解DataSource或任何其他特定资源，因为它使用容器的全局事务管理基础结构。

上述定义的dataSource bean使用jee命名空间中的<jndi-lookup />标签。有关更多信息，请参阅[The JEE schema](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/integration.html#xsd-schemas-jee)。



您也可以轻松地使用Hibernate本地事务，如以下示例所示。在这种情况下，您需要定义一个Hibernate LocalSessionFactoryBean，您的应用程序代码将用它来获取Hibernate Session实例。

DataSource bean定义将类似于前面显示的本地JDBC示例，因此在以下示例中不会显示。

```
如果由任何非JTA事务管理器使用的DataSource是通过JNDI查找并由Java EE容器管理的，那么它应该是非事务性的，因为将是Spring Framework（而不是Java EE容器）管理事务。
```

这种情况下的txManager bean是HibernateTransactionManager类型的。与DataSourceTransactionManager需要对DataSource的引用相同，HibernateTransactionManager需要对SessionFactory的引用。

```xml
<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="mappingResources">
        <list>
            <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
        </list>
    </property>
    <property name="hibernateProperties">
        <value>
            hibernate.dialect=${hibernate.dialect}
        </value>
    </property>
</bean>

<bean id="txManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager">
    <property name="sessionFactory" ref="sessionFactory"/>
</bean>
```

如果您正在使用Hibernate和Java EE容器管理的JTA事务，那么您只需要使用与之前JTA JDBC示例相同的JtaTransactionManager就可以了，不再需要hibernate的事务管理器。

```java
<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>
```

```
如果您使用JTA，那么无论使用什么数据访问技术，无论是JDBC，Hibernate JPA还是其他任何支持的技术，您的事务管理器定义都将保持不变。这是由于JTA事务是全局事务，它可以征用任何事务资源。
```

在所有这些情况下，应用程序代码不需要改变。您可以通过更改配置来更改事务的管理方式，即使这种更改意味着从本地事务转移到全局事务，反之亦然.

## 1.4 资源与事务同步

现在应该清楚如何创建不同的事务管理器，以及它们如何链接到需要同步到事务的相关资源（例如DataSourceTransactionManager链接JDBC数据源，HibernateTransactionManager链接Hibernate SessionFactory等等）。本节介绍应用程序代码如何直接或间接使用持久化API（如JDBC，Hibernate或JPA）确保正确创建，重用和清理这些资源。本节还讨论了如何通过相关PlatformTransactionManager触发（可选）事务同步。

### 1.4.1 高级的同步实现

首选的方法是使用Spring最高级别的基于模板的持久化集成API，或者使用和事务感知工厂bean或代理一起的原始ORM API来管理本地资源工厂。这些事务感知型解决方案在内部处理资源的创建和重用，清理，可选的资源事务同步以及异常映射。因此，用户数据访问代码不必处理这些任务，可以纯粹专注于非模板化的持久化逻辑。通常，使用原始ORM API或使用JdbcTemplate采取模板方法进行JDBC访问。这些解决方案在本参考文档的后续章节中详细介绍。

### 1.4.2 低级同步实现

如DataSourceUtils（用于JDBC），EntityManagerFactoryUtils（用于JPA），SessionFactoryUtils（用于Hibernate）等较低级别的类。当您希望应用程序代码直接处理本地持久化API的资源类型时，您可以使用这些类来确保获得正确的Spring Framework管理的实例，事务（可选）同步，并且处理过程中发生的异常正确地映射到一致的API。

例如，对于JDBC而言，不是调用DataSource的getConnection（）方法的传统JDBC方法，而是使用Spring的org.springframework.jdbc.datasource.DataSourceUtils类，如下所示：

```java
Connection conn = DataSourceUtils.getConnection(dataSource);
```

如果现有的事务已经有一个和这个connection同步，则返回该实例。否则，该方法调用会触发创建一个新的连接，该连接（可选）与任何现有事务同步，并可用于同一事务中的后续重用。如前所述，任何SQLException都被封装在Spring框架CannotGetJdbcConnectionException中，这是Spring框架未经检查的DataAccessExceptions的层次结构中的一个异常。这种异常实现为您提供了比从SQLException更多的信息，并确保跨数据库的可移植性，即使是跨不同的持久性技术。

这种实现也可以在没有Spring事务管理的情况下工作（事务同步是可选的），因此无论您是否使用Spring进行事务管理，都可以使用它。

当然，一旦你使用了Spring的JDBC支持，JPA支持或者Hibernate支持，你通常不会使用DataSourceUtils或其他的帮助类，因为通过使用Spring的事务抽象，比直接使用相关的API更快乐。例如，如果使用Spring JdbcTemplate或jdbc.object包里的类来简化JDBC的使用，在以上场景中，正确的连接获取在后台执行，而不需要编写任何特殊代码。

### 1.4.3. TransactionAwareDataSourceProxy

在最低级别的API是TransactionAwareDataSourceProxy类。这是一个目标DataSource的代理，它封装了目标DataSource以增加对Spring管理的事务的了解。在这方面，它类似于由Java EE服务器提供的事务性JNDI数据源。

除非现有的代码必须被调用并通过一个标准的JDBC DataSource接口实现，否则几乎不需要使用这个类。在这种情况下，这个代码有可能是可用的，但使用Spring管理事务，最好使用上面提到的更高级别的抽象来编写新的代码。

## 1.5。声明式事务管理

```
大多数Spring Framework用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此与非侵入式轻量级容器的理念最为一致。
```

Spring框架的声明式事务管理是通过Spring面向切面编程（AOP）实现的，尽管由于事务切面的代码随Spring Framework发行版一起提供，并且一般以模板化的方式使用，所以AOP概念通常不需要被理解就能有效使用这段代码。

Spring框架的声明式事务管理类似于EJB CMT，因为您可以将事务行为（或不指定它）指定到单个方法级别。如果需要，可以在事务上下文中调用setRollbackOnly（）方法。这两种事务管理的区别在于：

- 与JTA绑定的EJB CMT不同，Spring框架的声明式事务管理适用于任何环境。它可以使用JDBC，JPA或Hibernate，只需通过简单地调整配置文件来处理JTA事务或本地事务。
- 您可以将Spring Framework声明式事务管理应用于任何类，而不仅仅是诸如EJBs之类的特殊类。
- Spring框架提供了声明式的 [*rollback rules*](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction-declarative-rolling-back)，EJB没有这个特性。声明式和编程式事务都支持。
- Spring框架使您能够通过使用AOP来自定义事务行为。例如，您可以在事务回滚的情况下插入自定义行为。您还可以伴随事务通知添加任意的通知。而使用EJB CMT，除了使用setRollbackOnly（）之外，不能影响容器的事务管理行为。
- Spring框架不支持跨远程调用事务上下文传播，高端应用程序服务器也如此。如果您需要此功能，我们建议您使用EJB。但是，在使用这种功能之前要仔细考虑，因为通常情况下，不希望事务跨越远程调用。

```
TransactionProxyFactoryBean什么时候使用？
Spring 2.0及更高版本的声明式事务配置与以前的Spring版本有很大不同。主要区别在于不再需要配置TransactionProxyFactoryBean bean。
Spring 2.0之前的配置风格仍然是100％有效的配置;新的<tx：tags />标签相当于简单地为你定义TransactionProxyFactoryBean bean。
```

回滚rule的概念很重要：它使您能够指定哪些exception（和throwables）应该导致自动回滚。您可以在配置中以声明方式指定，而不是在Java代码中。因此，尽管您仍然可以调用TransactionStatus对象上的setRollbackOnly（）来回滚当前事务，但通常可以指定MyApplicationException必须总是导致回滚的规则。这个选项的显着优点是业务对象不依赖于事务基础结构。例如，他们通常不需要导入Spring事务API或其他Spring API。

虽然EJB容器默认行为会自动回滚系统异常（通常是runtime异常）的事务，但EJB CMT不会自动回滚应用程序异常（即除java.rmi.RemoteException之外的已检查异常）的事务。虽然声明式事务管理的Spring默认行为遵循EJB约定（仅在未检查的异常时自动回滚），但定制此行为通常很有用。

### 1.5.1 理解Spring框架的声明式事务实现

仅知道在类上面添加@Transactional注解是不够的，还要直达将@EnableTransactionManagement添加到你的configuration，然后明白它是如何工作的。本节将解释在发生事务相关问题时Spring Framework的声明式事务基础架构的内部工作原理。

关于Spring框架的声明式事务支持最重要的概念是通过 [*via AOP proxies*](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/core.html#aop-understanding-aop-proxies)来支持这种功能，并且事务性的通知是由元数据（目前是基于XML或基于注释的）来驱动的。 AOP与事务性元数据的结合产生了AOP代理，该代理使用TransactionInterceptor和相应的PlatformTransactionManager实现来驱动方法调用周围的事务

AOP部分介绍了 [the AOP section](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/core.html#aop)。

从概念上讲，调用事务代理的方法如下所示...

图略

### 1.5.2 声明式事务实现的示例

考虑以下接口及其实现。本示例使用Foo和Bar类仅作为占位符，以便您可以专注于事务使用，而不必关注特定的domain模型。就这个例子而言，DefaultFooService类在每个实现的方法的主体中抛出UnsupportedOperationException实例是合适的;它允许您查看创建的事务，然后回滚以响应UnsupportedOperationException实例。

```java
// the service interface that we want to make transactional

package x.y.service;

public interface FooService {

    Foo getFoo(String fooName);

    Foo getFoo(String fooName, String barName);

    void insertFoo(Foo foo);

    void updateFoo(Foo foo);

}
```

```java
// an implementation of the above interface

package x.y.service;

public class DefaultFooService implements FooService {

    public Foo getFoo(String fooName) {
        throw new UnsupportedOperationException();
    }

    public Foo getFoo(String fooName, String barName) {
        throw new UnsupportedOperationException();
    }

    public void insertFoo(Foo foo) {
        throw new UnsupportedOperationException();
    }

    public void updateFoo(Foo foo) {
        throw new UnsupportedOperationException();
    }

}
```

假设FooService接口的前两个方法getFoo（String）和getFoo（String，String）必须在具有只读语义的事务上下文中执行，而其他方法insertFoo（Foo）和updateFoo Foo），必须在具有读写语义的事务上下文中执行。接下来的几段代码将详细介绍以下配置。

```xml
<!-- from the file 'context.xml' -->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- this is the service object that we want to make transactional -->
    <bean id="fooService" class="x.y.service.DefaultFooService"/>

    <!-- the transactional advice (what 'happens'; see the <aop:advisor/> bean below) -->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <!-- the transactional semantics... -->
        <tx:attributes>
            <!-- all methods starting with 'get' are read-only -->
            <tx:method name="get*" read-only="true"/>
            <!-- other methods use the default transaction settings (see below) -->
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <!-- ensure that the above transactional advice runs for any execution
        of an operation defined by the FooService interface -->
    <aop:config>
        <aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/>
    </aop:config>

    <!-- don't forget the DataSource -->
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
        <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>
        <property name="username" value="scott"/>
        <property name="password" value="tiger"/>
    </bean>

    <!-- similarly, don't forget the PlatformTransactionManager -->
    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- other <bean/> definitions here -->

</beans>
```

检查前面的配置。你想创建一个事务性的fooService bean。要应用的事务语义被封装在<tx：advice />定义中。 <tx：advice />定义所有以'get'开始的方法都是在只读事务的上下文中执行的，而其他所有方法都是使用默认的事务语义执行的。将<tx：advice />标记的transaction-manager属性设置为将要驱动事务的PlatformTransactionManager bean的名称，在这种情况下为txManager bean。

```
如果您要连接的PlatformTransactionManager的bean name是transactionManager，则可以省略事务性通知（<tx：advice />）中的transaction-manager属性。如果您要连接的PlatformTransactionManager bean具有其他name，则必须显式指定transaction-manager属性，如上例所示。
```

<aop：config />定义确保由txAdvice bean定义的事务通知在程序的适当位置执行。首先定义一个与FooService接口（fooServiceOperation）中定义的任何操作的执行相匹配的切入点。然后，使用advisor将切入点与txAdvice相关联。结果表明在执行fooServiceOperation时，会运行由txAdvice定义的通知。

在<aop：pointcut />元素中定义的表达式是一个AspectJ切入点表达式;有关Spring中的切入点表达式的更多详细信息，请参阅[the AOP section](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/core.html#aop)。

一个常见的要求是使整个服务层都是事务性的。最好的办法就是改变切入点表达式来匹配服务层中的任何操作。例如：

```xml
<aop:config>
    <aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>
</aop:config>
```

在这个例子中，假设所有的服务接口都是在x.y.service包中定义的;请参阅*the AOP section *了解更多详情。

现在我们已经分析了配置，您可能会问自己，“好的...但是这个配置实际上做了什么？”。

上述配置将用于创建一个事务代理，该代理围绕从fooService bean定义创建的对象。代理将配置事务通知，以便在代理上调用适当的方法时，根据与该方法关联的事务配置，事务启动，挂起，标记为只读等。考虑下面的测试驱动上述配置的程序：

```java
public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml", Boot.class);
        FooService fooService = (FooService) ctx.getBean("fooService");
        fooService.insertFoo (new Foo());
    }
}
```

### 1.5.3回滚声明式事务

上一节概述了如何在应用程序中声明性地指定类（通常是服务层类）的事务设置的基础知识。本节介绍如何以简单的声明方式控制事务的回滚。

向Spring框架的事务基础架构表明事务将被回滚的推荐方法是从事务上下文中正在执行的代码中引发一个异常。 Spring框架的事务基础架构代码会捕获任何未处理的Exception，因为它会唤起调用堆栈，并确定是否标记事务以进行回滚。

在其默认配置中，Spring Framework的事务基础架构代码仅在运行时将未经检查的异常标记为回滚事务，也就是说，抛出的异常是RuntimeException的一个实例或子类。 （Error也将 - 默认 - 导致回滚）。事务性方法抛出的checked异常不会导致在默认配置中回滚。	

您可以精确地配置哪些Exception类型回滚事务，包括checked的异常。以下XML片段演示了如何配置特定应用程序特定的异常类型的回滚。

```xml
<tx:advice id="txAdvice" transaction-manager="txManager">
    <tx:attributes>
    <tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/>
    <tx:method name="*"/>
    </tx:attributes>
</tx:advice>
```

如果您不想在抛出异常时回滚事务，则还可以指定“不回滚规则”。下面的例子告诉Spring框架的事务基础结构，即使面对未处理的InstrumentNotFoundException，也要提交事务。

```xml
<tx:advice id="txAdvice">
    <tx:attributes>
    <tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/>
    <tx:method name="*"/>
    </tx:attributes>
</tx:advice>
```

当Spring框架的事务基础结构捕获一个异常，并且查询配置的回退规则以确定是否标记回滚事务时，最具体的匹配规则将胜出。因此，在以下配置的情况下，除了InstrumentNotFoundException之外的任何异常都会导致伴随式事务的回滚。

```xml
<tx:advice id="txAdvice">
    <tx:attributes>
    <tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/>
    </tx:attributes>
</tx:advice>
```

您也可以以编程方式指示所需的回滚。虽然非常简单，但这种方式是侵入式的，并且将代码紧密结合到Spring框架的事务基础架构上：

```java
public void resolvePosition() {
    try {
        // some business logic...
    } catch (NoProductInStockException ex) {
        // trigger rollback programmatically
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    }
}
```

如果可能，强烈建议您使用声明式方法来回滚。如果您确实需要，可以使用程序化回滚，而且编程式方式使用会在实现一个干净的基于POJO的体系结构时发生。

### 1.5.4 为不同的bean配置不同的事务语义

考虑一下你有多个服务层对象的场景，并且你想对它们中的每一个应用完全不同的事务配置。您可以通过定义具有不同切入点和advice-ref属性值的不同<aop：advisor />元素来执行此操作。

首先假定所有的服务层类都是在一个根x.y.service包中定义的。要使所有在该包（或子包中）中定义的类的实例都具有默认的事务配置，您可以编写以下代码：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <aop:config>

        <aop:pointcut id="serviceOperation"
                expression="execution(* x.y.service..*Service.*(..))"/>

        <aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/>

    </aop:config>

    <!-- these two beans will be transactional... -->
    <bean id="fooService" class="x.y.service.DefaultFooService"/>
    <bean id="barService" class="x.y.service.extras.SimpleBarService"/>

    <!-- ... and these two beans won't -->
    <bean id="anotherService" class="org.xyz.SomeService"/> <!-- (not in the right package) -->
    <bean id="barManager" class="x.y.service.SimpleBarManager"/> <!-- (doesn't end in 'Service') -->

    <tx:advice id="txAdvice">
        <tx:attributes>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... -->

</beans>
```

以下示例显示了如何使用完全不同的事务设置配置两个不同的Bean。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <aop:config>

        <aop:pointcut id="defaultServiceOperation"
                expression="execution(* x.y.service.*Service.*(..))"/>

        <aop:pointcut id="noTxServiceOperation"
                expression="execution(* x.y.service.ddl.DefaultDdlManager.*(..))"/>

        <aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/>

        <aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/>

    </aop:config>

    <!-- this bean will be transactional (see the 'defaultServiceOperation' pointcut) -->
    <bean id="fooService" class="x.y.service.DefaultFooService"/>

    <!-- this bean will also be transactional, but with totally different transactional settings -->
    <bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/>

    <tx:advice id="defaultTxAdvice">
        <tx:attributes>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <tx:advice id="noTxAdvice">
        <tx:attributes>
            <tx:method name="*" propagation="NEVER"/>
        </tx:attributes>
    </tx:advice>

    <!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... -->

</beans>
```

### 1.5.5 <tx：advice />设置

本部分总结了可以使用<tx：advice />标签指定的各种事务设置。默认的<tx：advice />设置是：

- [Propagation setting](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#tx-propagation) is `REQUIRED.`
- Isolation level is `DEFAULT.`
- Transaction is read/write.
- Transaction timeout defaults to the default timeout of the underlying transaction system, or none if timeouts are not supported.
- Any `RuntimeException` triggers rollback, and any checked `Exception` does not.

您可以更改这些默认设置;嵌套在<tx：advice />和<tx：attributes />中的<tx：method />标签的各种属性总结**如下：**

| Attribute         | Required? | Default  | Description                              |
| ----------------- | --------- | -------- | ---------------------------------------- |
| `name`            | Yes       |          | Method name(s) with which the transaction attributes are to be associated. The wildcard (*) character can be used to associate the same transaction attribute settings with a number of methods; for example, `get*`, `handle*`, `on*Event`, and so forth. |
| `propagation`     | No        | REQUIRED | Transaction propagation behavior.        |
| `isolation`       | No        | DEFAULT  | Transaction isolation level.             |
| `timeout`         | No        | -1       | Transaction timeout value (in seconds).  |
| `read-only`       | No        | false    | Is this transaction read-only?           |
| `rollback-for`    | No        |          | `Exception(s)` that trigger rollback; comma-delimited. For example,`com.foo.MyBusinessException,ServletException.` |
| `no-rollback-for` | No        |          | `Exception(s)` that do *not* trigger rollback; comma-delimited. For example,`com.foo.MyBusinessException,ServletException.` |

### 1.5.6 使用@Transactional

除了基于XML的事务配置的声明式方法之外，您还可以使用基于注释的方法。直接在Java源代码中声明事务语义会使声明更接近配置的代码。没有太多的不必要的耦合的危险，因为意味着事务使用的代码几乎总是以这种方式部署。

```
标准的javax.transaction.Transactional注解也被支持作为Spring自己注解的一个直接替代。有关更多详细信息，请参阅JTA 1.2文档。
```

通过使用@Transactional注释提供的易用性最好用一个例子来说明，这在下面的文字中有解释。考虑下面的类定义：

```java
// the service class that we want to make transactional
@Transactional
public class DefaultFooService implements FooService {

    Foo getFoo(String fooName);

    Foo getFoo(String fooName, String barName);

    void insertFoo(Foo foo);

    void updateFoo(Foo foo);
}
```

当上面的POJO在Spring IoC容器中定义为一个bean时，只需添加一行XML配置就可以使bean实例成为事务性的：

```xml
<!-- from the file 'context.xml' -->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- this is the service object that we want to make transactional -->
    <bean id="fooService" class="x.y.service.DefaultFooService"/>

    <!-- enable the configuration of transactional behavior based on annotations -->
    <tx:annotation-driven transaction-manager="txManager"/><!-- a PlatformTransactionManager is still required -->
    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!-- (this dependency is defined somewhere else) -->
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- other <bean/> definitions here -->

</beans>
```

```
如果您要使用的PlatformTransactionManager的Bean name是transactionManager，则可以省略<tx：annotation-driven />标记中的transaction-manager属性。如果要依赖注入的PlatformTransactionManager bean具有任何其他名称，则必须显式使用transaction-manager属性，如上例所示。
```

```
如果您使用的是基于Java的配置，则@EnableTransactionManagement注解提供等效的支持。只需将注释添加到@Configuration类即可。查看javadocs的全部细节。
```

```
                                             方法可见性和@Transactional
 在使用代理时，@Transactional注释仅应用于public的方法。如果使用@Transactional注释标注protected，private或package-visible方法，虽然不会引发错误，但注释的方法不会应用已配置的事务设置。如果您需要注释非公共方法，请考虑使用AspectJ（请参见下文）。
```

您可以将@Transactional注释放置在类的接口定义，接口上的方法，类定义或类的公共方法之前。但是，仅仅存在@Transactional注释不足以激活事务行为。 @Transactional注释仅仅是一些元数据，可以被一些具有@ Transactional-aware的运行时基础结构使用，并且可以使用元数据来配置具有事务行为的合适的Bean。在前面的示例中，<tx：annotation-driven />元素用于开启事务行为。

```
Spring建议您只使用@Transactional注释来注释具体类（以及具体类的方法），而不是注释接口。您当然可以将@Transactional注释放在一个接口（或一个接口方法）上，但是这只能在您使用基于接口的代理的情况下使用。 Java注释没有从接口继承的事实意味着，如果您使用的是基于类的代理（proxy-target-class =“true”）或基于交织的切面（mode =“aspectj”），那么事务设置是没有被代理和编织基础架构认可，并且对象不会被封装在一个事务代理中，这肯定是不好的。
```

```
在proxy mode下（这是默认模式），只拦截通过代理进入的外部方法调用。这意味着即使被调用的方法被标记为@Transactional，自调用实际上是目标对象的一个方法调用目标对象内的另一个方法，也不会导致实际的事务。此外，代理必须完全初始化，以提供预期的行为，所以您不应该在初始化代码中依赖此功能，例如@PostConstruct。
```

如果您期望自我调用也能应用事务，请考虑使用AspectJ模式（请参阅下表中的mode属性）。在这种情况下，首先不会有代理;相反，目标类将被编织（即，其字节代码将被修改），以便将@Transactional转换为任何类型的方法的运行时行为。

| XML Attribute         | Annotation Attribute                     | Default                   | Description                              |
| --------------------- | ---------------------------------------- | ------------------------- | ---------------------------------------- |
| `transaction-manager` | N/A (See `TransactionManagementConfigurer`javadocs) | transactionManager        | 要使用的transactionManager的名称。只有在事务管理器的名称不是transactionManager的情况下才需要，如上例所示。 |
| `mode`                | `mode`                                   | proxy                     | 默认模式“proxy”处理带注释的bean，使用Spring的AOP框架进行代理（遵循代理语义，如上所述，仅适用于通过代理进入的方法调用）。替代mode “aspectj”用Spring的AspectJ事务通知编织受影响的类，修改目标类字节代码以应用于任何类型的方法调用。 AspectJ编织要求classpath中的spring-aspects.jar以及load-time weaving（或compile-time weaving）。 （有关如何设置加载时织入的详细信息，请参阅Spring配置。） |
| `proxy-target-class`  | `proxyTargetClass`                       | false                     | 这个属性仅适用于proxy mode。控制为@Transactional注解类创建哪种类型的事务代理。如果proxy-target-class属性设置为true，则创建基于类的代理。如果proxy-target-class为false或者该属性被省略，则创建标准的基于JDK接口的代理。 （请参阅[Proxying mechanisms](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/core.html#aop-proxying)以详细了解不同的代理类型。） |
| `order`               | `order`                                  | Ordered.LOWEST_PRECEDENCE | 定义应用于@Transactional注解bean的事务通知的顺序。 （有关与AOP建议的排序有关的规则的更多信息，请参阅 [Advice ordering](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/core.html#aop-ataspectj-advice-ordering)。）没有指定排序意味着AOP子系统确定通知的顺序。 |

用于处理@Transactional注释的默认建议模式是“proxy”，它仅允许通过代理的方法调用;同一class的自我方法调用不能被这样的拦截。对于更高级的拦截模式，考虑切换到“aspectj”模式并结合compile/load-time weaving.。

proxy-target-class属性控制为@Transactional注解类创建哪种类型的事务代理。如果将proxy-target-class设置为true，则会创建基于类的代理。如果proxy-target-class为false或者该属性被省略，则创建标准的基于JDK接口的代理。 （请参阅  [[aop-proxying\]](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#aop-proxying) 了解不同代理类型的讨论。）

@EnableTransactionManagement和<tx：annotation-driven />仅在它们定义的同一个应用程序上下文中查找@Transactional bean。这意味着，如果将DispatcherServlet的注释驱动配置放在WebApplicationContext中，它只会检查controller中的@Transactional bean，而不是你的service。有关更多信息，请参阅 [MVC](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/web.html#mvc-servlet)。

评估方法的事务设置时，派生最多的位置优先。在下面的例子中，DefaultFooService类在类级别注释了只读事务的设置，但同一个类中updateFoo（Foo）方法的@Transactional注释优先于定义class level的事务设置。

```java
@Transactional(readOnly = true)
public class DefaultFooService implements FooService {

    public Foo getFoo(String fooName) {
        // do something
    }

    // these settings have precedence for this method
    @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
    public void updateFoo(Foo foo) {
        // do something
    }
}
```

#### @Transactional settings

@Transactional注解是指定一个接口，类或方法必须具有事务语义的元注解;例如，“在调用此方法时启动全新的只读事务，暂停任何现有事务”。默认的@Transactional设置如下：

- Propagation setting is `PROPAGATION_REQUIRED.`
- Isolation level is `ISOLATION_DEFAULT.`
- Transaction is read/write.
- Transaction timeout defaults to the default timeout of the underlying transaction system, or to none if timeouts are not supported.
- Any `RuntimeException` triggers rollback, and any checked `Exception` does not.

这些默认设置可以改变;下表汇总了@Transactional注释的各种属性：

| Property                                 | Type                                     | Description                              |
| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| [value](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#tx-multiple-tx-mgrs-with-attransactional) | String                                   | Optional qualifier specifying the transaction manager to be used. |
| [propagation](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#tx-propagation) | enum: `Propagation`                      | Optional propagation setting.            |
| `isolation`                              | enum: `Isolation`                        | Optional isolation level.                |
| `readOnly`                               | boolean                                  | Read/write vs. read-only transaction     |
| `timeout`                                | int (in seconds granularity)             | Transaction timeout.                     |
| `rollbackFor`                            | Array of `Class` objects, which must be derived from `Throwable.` | Optional array of exception classes that *must* cause rollback. |
| `rollbackForClassName`                   | Array of class names. Classes must be derived from `Throwable.` | Optional array of names of exception classes that *must* cause rollback. |
| `noRollbackFor`                          | Array of `Class` objects, which must be derived from `Throwable.` | Optional array of exception classes that *must not* cause rollback. |
| `noRollbackForClassName`                 | Array of `String` class names, which must be derived from `Throwable.` | Optional array of names of exception classes that *must not* cause rollback. |

目前，您不能显式控制事务name，其中'name'将在事务监视器（如果适用）（例如，WebLogic的事务监视器）中显示以及日志记录输出。对于声明式事务，事务名称始终是完全限定的类名加上事务通知的类的方法名称。例如，如果BusinessService类的handlePayment（..）方法启动了一个事务，则该事务的名称将是：com.foo.BusinessService.handlePayment。

#### @Transactional配置多个事务管理器

大多数Spring应用程序只需要一个事务管理器，但可能会出现在单个应用程序中需要多个独立事务管理器的情况。 @Transactional注释的value属性可以用来指定要使用的PlatformTransactionManager的标识。这可以是事务管理器bean的bean名称或限定符值。例如，使用限定符符号表示

```java
public class TransactionalService {

    @Transactional("order")
    public void setSomething(String name) { ... }

    @Transactional("account")
    public void doSomething() { ... }
}
```

可以与应用程序上下文中的以下事务管理器bean声明结合使用。

```java
<tx:annotation-driven/>

    <bean id="transactionManager1" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        ...
        <qualifier value="order"/>
    </bean>

    <bean id="transactionManager2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        ...
        <qualifier value="account"/>
    </bean>
```

在这种情况下，TransactionalService上的两个方法将在单独的事务管理器下运行，并由“order”和“account”限定符进行区分。如果没有找到指定限定名称的PlatformTransactionManager bean，那么仍然会使用<tx：annotation-driven>默认的目标bean名称transactionManager。

#### 自定义事务注解

如果您发现您在许多不同的方法上重复使用@Transactional的相同属性，那么Spring的元注释支持允许您为特定场景自定义快捷方式注释。例如，定义以下注释

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Transactional("order")
public @interface OrderTx {
}

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Transactional("account")
public @interface AccountTx {
}
```

我们可以重写上一节中的示例

```java
public class TransactionalService {

    @OrderTx
    public void setSomething(String name) { ... }

    @AccountTx
    public void doSomething() { ... }
}
```

这里我们使用了之前的语法来定义事务管理器限定符，这个快捷方式注解还可以包含propagation 行为，rollback rules, timeouts等。

### 1.5.7 事务传播

本节介绍Spring中事务传播的一些语义。请注意，本节不是事务传播的介绍。而是详细介绍了Spring中事务传播的一些语义。

在Spring管理的事务中，要注意物理和逻辑事务之间的区别，以及传播设置如何应用于这个区别。

#### Required

![https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/images/tx_prop_required.png]()

PROPAGATION_REQUIRED

当传播设置为PROPAGATION_REQUIRED时，将为应用该设置的每个方法创建逻辑事务范围。每个这样的逻辑事务作用域可以单独确定rollback-only状态，其中外部事务作用域在逻辑上独立于内部事务作用域。当然，在标准PROPAGATION_REQUIRED行为的情况下，所有这些范围将被映射到相同的物理事务。因此，设置在内部事务范围内的rollback-only标记确实会影响外部事务实际提交的机会（如您所期望的那样）。

但是，在内部事务范围设置rollback-only标记的情况下，外部事务本身还没有决定回滚，因此回滚（由内部事务范围默默触发）是意外的。相应的UnexpectedRollbackException被抛出。这是预期的行为，以便事务的调用者永远不会被误导而认为事务已经提交，实际事务没有提交。所以如果一个内部事务（外部调用者不知道的）默默地将一个事务标记为只回滚，外部调用者仍然调用commit。外部调用者需要接收UnexpectedRollbackException来清楚地表明执行了回滚。

#### RequiresNew

![https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/images/tx_prop_requires_new.png]()

PROPAGATION_REQUIRES_NEW

与PROPAGATION_REQUIRED相比，PROPAGATION_REQUIRES_NEW对每个受影响的事务范围使用完全独立的事务。在这种情况下，底层的物理事务是不同的，因此可以独立提交或回滚，外部事务不受内部事务的回滚状态的影响。

#### Nested

PROPAGATION_NESTED使用单个物理事务，具有多个可以回滚到的保存点。这种部分回滚允许内部事务作用域触发其作用域的回滚，尽管某些操作已经回滚，但外部事务能够继续物理事务。该设置通常映射到JDBC保存点，因此只能用于JDBC资源事务。请参阅Spring的DataSourceTransactionManager。

### 1.5.8. 除了事务通知，配置其它通知

假设您要执行事务性和一些基本的性能分析通知。你如何在<tx：annotation-driven />的情况下实现这一点？

当您调用updateFoo（Foo）方法时，您需要执行以下操作：

- Configured profiling aspect starts up.
- Transactional advice executes.
- Method on the advised object executes.
- Transaction commits.
- Profiling aspect reports exact duration of the whole transactional method invocation.

本章并不关心如何解释AOP（除非适用通知）。有关以下AOP配置和AOP的详细介绍，请参阅[AOP](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/core.html#aop)。

这里是上面讨论的一个简单的性能分析切面的代码。通知的顺序是通过Ordered接口控制的。有关通知顺序的完整信息，请参阅 [Advice ordering](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/core.html#aop-ataspectj-advice-ordering) 。

```java
package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;
import org.springframework.core.Ordered;

public class SimpleProfiler implements Ordered {

    private int order;

    // allows us to control the ordering of advice
    public int getOrder() {
        return this.order;
    }

    public void setOrder(int order) {
        this.order = order;
    }

    // this method is the around advice
    public Object profile(ProceedingJoinPoint call) throws Throwable {
        Object returnValue;
        StopWatch clock = new StopWatch(getClass().getName());
        try {
            clock.start(call.toShortString());
            returnValue = call.proceed();
        } finally {
            clock.stop();
            System.out.println(clock.prettyPrint());
        }
        return returnValue;
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean id="fooService" class="x.y.service.DefaultFooService"/>

    <!-- this is the aspect -->
    <bean id="profiler" class="x.y.SimpleProfiler">
        <!-- execute before the transactional advice (hence the lower order number) -->
        <property name="order" value="1"/>
    </bean>

    <tx:annotation-driven transaction-manager="txManager" order="200"/>

    <aop:config>
            <!-- this advice will execute around the transactional advice -->
            <aop:aspect id="profilingAspect" ref="profiler">
                <aop:pointcut id="serviceMethodWithReturnValue"
                        expression="execution(!void x.y..Service.(..))"/>
                <aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/>
            </aop:aspect>
    </aop:config>

    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
        <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>
        <property name="username" value="scott"/>
        <property name="password" value="tiger"/>
    </bean>

    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

</beans>
```

上述配置的结果是一个fooService bean，它具有按所需顺序应用分析和事务处理的切面。您可以用类似的方式配置任何数量的其他方面。

下面的例子和上面的例子一样，但是使用纯粹的XML声明方法。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean id="fooService" class="x.y.service.DefaultFooService"/>

    <!-- the profiling advice -->
    <bean id="profiler" class="x.y.SimpleProfiler">
        <!-- execute before the transactional advice (hence the lower order number) -->
        <property name="order" value="1"/>
    </bean>

    <aop:config>
        <aop:pointcut id="entryPointMethod" expression="execution(* x.y..Service.(..))"/>
        <!-- will execute after the profiling advice (c.f. the order attribute) -->

        <aop:advisor advice-ref="txAdvice" pointcut-ref="entryPointMethod" order="2"/>
        <!-- order value is higher than the profiling aspect -->

        <aop:aspect id="profilingAspect" ref="profiler">
            <aop:pointcut id="serviceMethodWithReturnValue"
                    expression="execution(!void x.y..Service.(..))"/>
            <aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/>
        </aop:aspect>

    </aop:config>

    <tx:advice id="txAdvice" transaction-manager="txManager">
        <tx:attributes>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <!-- other <bean/> definitions such as a DataSource and a PlatformTransactionManager here -->

</beans>
```

上述配置的结果将是一个fooService bean，它将按顺序执行的性能分析和事务处理切面。如果您希望在事务性通知开始之后和事务性通知结束之前执行性能分析通知，那么只需交换性能分析方面bean的order属性的值，使其高于事务性建议的order值。

您以类似的方式配置其他方面。

### 1.5.9. Using @Transactional with AspectJ

通过AspectJ切面，还可以在Spring容器之外使用Spring框架的@Transactional支持。为此，首先使用@Transactional注解注释您的类（以及您的类的方法），然后将您的应用程序与spring-aspects.jar中定义的org.springframework.transaction.aspectj.AnnotationTransactionAspect结合（编织）。该方面还必须配置一个事务管理器。您当然可以使用Spring框架的IoC容器来处理切面的依赖注入。配置切面的事务管理器的最简单方法是使用<tx：annotation-driven />元素，并按照 [Using @Transactional](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction-declarative-annotations)中的描述将aspect属性指定为aspectj。因为我们将重点放在Spring容器之外运行的应用程序中，所以我们将向您展示如何以编程方式执行它。

在继续之前，您可能需要分别阅读 [Using @Transactional](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction-declarative-annotations) and [AOP](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/core.html#aop)

```java
// construct an appropriate transaction manager
DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());

// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods
AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);
```

```
当使用这个方面时，你必须注解实现类（和/或类中的方法），而不是类实现的接口（如果有的话）。 AspectJ遵循Java的规则，接口上的注释不被继承。
```

类的@Transactional注释指定类中任何方法执行的默认事务语义。

类中的方法的@Transactional注释将覆盖类注释（如果存在）给定的默认事务语义。任何方法都可以被注释，而不管可见性如何。

要使用AnnotationTransactionAspect编织您的应用程序，您必须使用AspectJ构建应用程序（请参阅“ [AspectJ Development Guide](https://www.eclipse.org/aspectj/doc/released/devguide/index.html)”）或使用 load-time编织。请参阅[Load-time weaving with AspectJ in the Spring Framework](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/core.html#aop-aj-ltw)，以了解使用AspectJ进行 load-time织入的讨论。

## 1.6 编程式事务管理

Spring Framework提供了两种编程式事务管理方式：

- Using the `TransactionTemplate`.
- Using a `PlatformTransactionManager` implementation directly.

Spring团队通常建议使用TransactionTemplate进行编程事务管理。第二种方法类似于使用JTA UserTransaction API，虽然异常处理不太麻烦。

### 1.6.1使用TransactionTemplate

TransactionTemplate采用与其他Spring模板（如JdbcTemplate）相同的方式。它使用一个回调方法，使应用程序代码免于模板获取和释放事务资源，并产生意向驱动的代码，因为编写的代码只关注开发人员想要做什么。

```
正如你将会在下面的例子中看到的那样，使用TransactionTemplate会将你与Spring的事务基础结构和API结合起来。编程式事务管理是否适合您的开发需求是您必须自己做出的决定。
```

应用程序代码必须在事务性上下文中执行，并且将显式使用TransactionTemplate，如下所示。作为应用程序开发人员，您可以编写一个TransactionCallback实现（通常表示为匿名内部类），该实现包含需要在事务上下文中执行的代码。然后，将自定义TransactionCallback的实例传递给TransactionTemplate上公开的execute（..）方法。

```java
public class SimpleService implements Service {

    // single TransactionTemplate shared amongst all methods in this instance
    private final TransactionTemplate transactionTemplate;

    // use constructor-injection to supply the PlatformTransactionManager
    public SimpleService(PlatformTransactionManager transactionManager) {
        Assert.notNull(transactionManager, "The 'transactionManager' argument must not be null.");
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }

    public Object someServiceMethod() {
        return transactionTemplate.execute(new TransactionCallback() {
            // the code in this method executes in a transactional context
            public Object doInTransaction(TransactionStatus status) {
                updateOperation1();
                return resultOfUpdateOperation2();
            }
        });
    }
}
```

如果没有返回值，则使用TransactionCallbackWithoutResult类，如下所示：

```java
transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    protected void doInTransactionWithoutResult(TransactionStatus status) {
        updateOperation1();
        updateOperation2();
    }
});
```

回调中的代码可以通过调用提供的TransactionStatus对象上的setRollbackOnly（）方法来回滚事务：

```java
transactionTemplate.execute(new TransactionCallbackWithoutResult() {

    protected void doInTransactionWithoutResult(TransactionStatus status) {
        try {
            updateOperation1();
            updateOperation2();
        } catch (SomeBusinessExeption ex) {
            status.setRollbackOnly();
        }
    }
});
```

#### 指定事务设置

您可以在TransactionTemplate上以编程方式或在配置中指定事务设置，例如传播模式，隔离级别，超时等。 TransactionTemplate实例默认具有[default transactional settings](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction-declarative-txadvice-settings)。以下示例显示了针对特定TransactionTemplate的事务设置：

```java
public class SimpleService implements Service {

    private final TransactionTemplate transactionTemplate;

    public SimpleService(PlatformTransactionManager transactionManager) {
        Assert.notNull(transactionManager, "The 'transactionManager' argument must not be null.");
        this.transactionTemplate = new TransactionTemplate(transactionManager);

        // the transaction settings can be set here explicitly if so desired
        this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
        this.transactionTemplate.setTimeout(30); // 30 seconds
        // and so forth...
    }
}
```

以下示例使用Spring XML配置定义了一个TransactionTemplate，其中包含一些自定义事务设置。然后，可以将sharedTransactionTemplate注入到所需的尽可能多的service中。

```xml
<bean id="sharedTransactionTemplate"
        class="org.springframework.transaction.support.TransactionTemplate">
    <property name="isolationLevelName" value="ISOLATION_READ_UNCOMMITTED"/>
    <property name="timeout" value="30"/>
</bean>"
```

最后，TransactionTemplate类的实例是线程安全的，在这种情况下不保持任何会话状态。但是，TransactionTemplate实例会保持配置状态，所以虽然许多类可以共享TransactionTemplate的单个实例，但是如果某个类需要使用具有不同设置（例如，不同的隔离级别）的TransactionTemplate，则需要创建两个不同的TransactionTemplate实例。

## 1.6.2 使用PlatformTransactionManager

略

## 1.7  编程和声明式事务管理选择哪一个

当您只有少量的事务操作时，编程事务管理通常是一个好主意。例如，如果您的Web应用程序只需要某些更新操作的事务，则您可能不希望使用Spring或任何其他技术来设置事务代理。在这种情况下，使用TransactionTemplate可能是一个好方法。另外，只有使用编程式事务管理，才可以设置事务的名字。

另一方面，如果您的应用程序有大量的事务操作，则声明式事务管理通常是值得的。它使事务管理不受业务逻辑的影响，并且不难配置。当使用Spring框架而不是EJB CMT时，声明式事务管理的配置成本大大降低。

## 1.8 事务绑定事件

从Spring 4.2开始，event的listener可以被绑定到事务的一个阶段。典型的例子是在事务成功完成时处理事件：当事务的结果确实会影响listener时，这允许事件被更灵活地使用。

注册常规事件侦听器是通过@EventListener注释完成的。如果您需要使用@TransactionalEventListener将其绑定到事务。当您这样做时，默认情况下，侦听器将被绑定到事务的commit阶段。

我们举一个例子来说明这个概念。假定一个组件发布一个订单创建的事件，并且我们想要定义一个监听器，它只能在事务成功提交的时候处理这个事件：

```java
@Component
public class MyComponent {

    @TransactionalEventListener
    public void handleOrderCreatedEvent(CreationEvent<Order> creationEvent) {
        ...
    }
}
```

TransactionalEventListener注释公开了一个phase属性，它允许定制侦听器应该绑定到事务的哪个阶段。有效的阶段是BEFORE_COMMIT，AFTER_COMMIT（默认），AFTER_ROLLBACK和   AFTER_COMPLETION即事务完成（无论是提交还是回滚）。

如果没有事务正在运行，则根本不会调用监听器，因为我们无法遵守所需的语义。但是可以通过将注释的fallbackExecution属性设置为true来覆盖该行为。

## 1.9. Application server-specific integration

Spring的事务抽象通常是应用程序服务器不可知的。此外，Spring的JtaTransactionManager类可以选择性地为JTA UserTransaction和TransactionManager对象执行JNDI查找，它会自动检测后者对象的位置，而后者因应用程序服务器而异。有权访问JTA TransactionManager这一特点允许增强事务语义，特别是支持事务挂起。有关详细信息，请参阅JtaTransactionManager javadocs。

Spring的JtaTransactionManager是在Java EE应用程序服务器上运行的标准选择，并且可以在所有通用服务器上运行。诸如事务挂起之类的高级功能也可以在许多服务器上运行，包括GlassFish，JBoss和Geronimo，不需要任何特殊的配置。但是，为了完全支持事务挂起和进一步的高级集成，Spring为WebLogic Server和WebSphere提供了特殊的适配器。这些适配器将在下面的章节中讨论。

对于标准方案（包括WebLogic Server和WebSphere），请考虑使用方便的<tx：jta-transaction-manager />配置元素。配置后，此元素将自动检测基础服务器，并选择可用于该平台的最佳事务管理器。这意味着您将不必明确地配置特定于服务器的适配器类（如以下各节所述）;相反，它们是自动选择的，标准JtaTransactionManager作为默认的选择。

### 1.9.1. IBM WebSphere

在WebSphere 6.1.0.9及更高版本上，建议使用的Spring JTA事务管理器是WebSphereUowTransactionManager。这个特殊的适配器利用IBM的UOWManager API，它在WebSphere Application Server 6.1.0.9及更高版本中可用。使用此适配器，IBM正式支持Spring驱动的事务挂起（由PROPAGATION_REQUIRES_NEW启动挂起/恢复）。

### 1.9.2. Oracle WebLogic Server

在WebLogic Server 9.0或更高版本上，通常使用WebLogicJtaTransactionManager而不是JtaTransactionManager类。正常的JtaTransactionManager的这个特殊的WebLogic特定的子类在WebLogic管理的事务环境中支持Spring的事务定义的全部功能，超越了标准的JTA语义：功能包括事务名称，每个事务的隔离级别以及在所有情况下正确地恢复事务。

## 1.10 解决常见的问题

### 1.10.1 对特定的数据源使用错误的事务管理器

根据您选择的事务技术和需求使用正确的PlatformTransactionManager实现。Spring框架仅仅提供了一个简单和便携的抽象。如果使用全局事务，则必须使用org.springframework.transaction.jta.JtaTransactionManager类（或[application server-specific subclass](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction-application-server-integration)）来执行所有事务操作。否则，事务基础架构将尝试在资源（如容器DataSource实例）上执行本地事务。这样的本地事务没有意义，并且一个好的应用程序服务器会把这种情况视为错误。

## 1.11 更多的资料

有关Spring框架的事务支持的更多信息：

- [Distributed transactions in Spring, with and without XA](http://www.javaworld.com/javaworld/jw-01-2009/jw-01-spring-transactions.html) i是一个JavaWorld演示文稿，Spring的David Syer在Spring应用程序中引导您完成七种分布式事务模式，其中三种使用XA，四种不使用。
- [Java Transaction Design Strategies](http://www.infoq.com/minibooks/JTDS)是InfoQ提供的一本书，它提供了有关Java中事务的快速入门介绍。它还包括如何使用Spring框架和EJB3框架配置事务的示例。

# 2. DAO support

## 2.1介绍

Spring中的 Data Access Object（DAO）支持旨在以一致的方式轻松处理JDBC，Hibernate或JPA等数据访问技术。这使得人们可以相当容易地在上述持久性技术之间进行切换，并且还可以让人们无需担心捕获每种技术特有的异常。

## 2.2 一致的异常层次结构

Spring提供了一种从特定技术的异常（如SQLException）转换到spring自己的异常类层次结构（DataAccessException作为根异常）的方便转换。这些异常包装了原始的异常，所以不会有任何风险可能会丢失任何可能出错的信息。

除JDBC异常外，Spring还可以封装 Hibernate-specific 的异常，将它们转换为一组运行时异常（对于JPA异常也是如此）。这使得人们只能在适当的层次上处理大多数不可恢复的持久性异常，而不会在一个DAO中产生令人讨厌的样板化的catch-and-throw块和异常声明。 （仍然可以在任何需要的地方捕获和处理异常）。如上所述，JDBC异常（包括特定于数据库的方言）也被转换为相同的层次结构，这意味着可以在一致的编程模型中使用JDBC执行一些操作。

Spring支持各种ORM框架的各种模板类都支持上述规则。如果使用基于拦截器的类，那么应用程序必须关心处理HibernateExceptions和PersistenceExceptions本身，最好分别委托给SessionFactoryUtils的convertHibernateAccessException（..）或convertJpaAccessException（）方法。这些方法将异常转换为与org.springframework.dao异常层次结构中的异常兼容的异常。由于PersistenceExceptions没有checked，它们也可以简单地被抛出，尽管在异常方面牺牲了泛型的DAO抽象。

![https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/images/DataAccessException.png]()

## 2.3 用于配置DAO或Repository 类的注解

确保数据访问对象（DAO）或Repository 提供异常转换的最佳方法是使用@Repository注释。此注释还允许component scanning支持查找和配置您的DAO和存储库，而无需为其提供XML配置条目。

```java
@Repository
public class SomeMovieFinder implements MovieFinder {
    // ...
}
```

任何DAO或存储库实现都需要访问持久性资源，具体取决于所使用的持久性技术;例如，基于JDBC的存储库将需要访问JDBC数据源;一个基于JPA的仓库将需要访问一个EntityManager。最简单的方法是使用@Autowired，@Inject，@Resource或@PersistenceContext注解之一注入此资源依赖项。这是一个JPA存储库的例子：

```java
@Repository
public class JpaMovieFinder implements MovieFinder {

    @PersistenceContext
    private EntityManager entityManager;

    // ...

}
```

如果您使用的是经典的Hibernate API，则可以注入SessionFactory：

```java
@Repository
public class HibernateMovieFinder implements MovieFinder {

    private SessionFactory sessionFactory;

    @Autowired
    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    // ...

}
```

我们在这里展示的最后一个例子是典型的JDBC支持。你可以将DataSource注入一个初始化方法，在这个方法中你将使用这个DataSource创建一个JdbcTemplate和其他数据访问支持类，如SimpleJdbcCall等。

```java
@Repository
public class JdbcMovieFinder implements MovieFinder {

    private JdbcTemplate jdbcTemplate;

    @Autowired
    public void init(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    // ...

}
```

有关如何配置应用程序上下文以利用这些注释的详细信息，请参阅每个持久性技术的具体范围。

# 3. Data access with JDBC

## 3.1  Spring Framework JDBC简介

Spring Framework JDBC抽象提供的增值功能在下表列出的一系列操作最能体现。下表显示了Spring将处理的操作以及应用程序开发人员应负责的操作。

| Action                                   | Spring | You  |
| ---------------------------------------- | ------ | ---- |
| Define connection parameters.            |        | X    |
| Open the connection.                     | X      |      |
| Specify the SQL statement.               |        | X    |
| Declare parameters and provide parameter values |        | X    |
| Prepare and execute the statement.       | X      |      |
| Set up the loop to iterate through the results (if any). | X      |      |
| Do the work for each iteration.          |        | X    |
| Process any exception.                   | X      |      |
| Handle transactions.                     | X      |      |
| Close the connection, statement and resultset. | X      |      |

Spring框架负责处理所有可能导致JDBC开发的枯燥乏味的API的底层细节。

### 3.1.1 为JDBC数据库访问选择一种实现方式

您可以选择几种方法来构成JDBC数据库访问的基础。除了三种JdbcTemplate之外，新的SimpleJdbcInsert和SimplejdbcCall实现方式优化了数据库元数据，RDBMS Object style采用了更类似于JDO Query设计的面向对象的方式。一旦你开始使用这些方式之一，你仍然可以混合使用这些方式。所有的方式都需要一个兼容JDBC 2.0的驱动程序，并且一些高级功能需要一个JDBC 3.0驱动程序。

JdbcTemplate是最经典的Spring JDBC方法。

NamedParameterJdbcTemplate封装了一个JdbcTemplate来提供命名参数，而不是传统的JDBC “？”占位符。当你有一个SQL语句的多个参数时，这种方法提供了更好的可读性和易用性。

SimpleJdbcInsert和SimpleJdbcCall优化数据库元数据以限制必要的配置数量。这种方法简化了编码，只需要提供表或过程的名称，并提供匹配列名称的参数映射。这只适用于数据库提供足够的元数据。如果数据库不提供此元数据，则必须提供参数的显式配置。

RDBMS对象（包括MappingSqlQuery，SqlUpdate和StoredProcedure）要求您在数据访问层的初始化期间创建可重用和线程安全的对象。这种方法是在JDO Query之后建模的，JDO Query中您定义了查询字符串，声明了参数并编译query对象。一旦你这样做，执行方法可以被多次调用，并传入不同的参数值。

### 3.1.2.包结构

Spring框架的JDBC抽象框架由四个不同的包组成，即`core`, `datasource`, `object`, and `support`.

org.springframework.jdbc.core包中包含JdbcTemplate类及其各种回调接口以及各种相关的类。名为org.springframework.jdbc.core.simple的子包包含SimpleJdbcInsert和SimpleJdbcCall类。另一个名为org.springframework.jdbc.core.namedparam的子包包含NamedParameterJdbcTemplate类和相关的支持类。请参阅 [Using the JDBC core classes to control basic JDBC processing and error handling](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-core), [JDBC batch operations](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-advanced-jdbc), and [Simplifying JDBC operations with the SimpleJdbc classes](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-simple-jdbc).

org.springframework.jdbc.datasource包中包含一个用于简化DataSource访问的实用程序类，以及各种简单的DataSource实现，可用于在Java EE容器之外测试和运行未经修改的JDBC代码。名为org.springfamework.jdbc.datasource.embedded的子包提供了使用Java数据库引擎（如HSQL，H2和Derby）创建嵌入式数据库的支持。请参阅 [Controlling database connections](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-connections) and [Embedded database support](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-embedded-database-support).

org.springframework.jdbc.object包中包含的类将RDBMS查询，更新和存储过程表示为线程安全的可重用对象。请参阅 [Modeling JDBC operations as Java objects](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-object)。虽然由查询返回的对象与数据库断开连接，但这种实现方式是由JDO建模的。这个更高级别的JDBC抽象取决于org.springframework.jdbc.core包中的低级抽象。

org.springframework.jdbc.support包提供了SQLException转换功能和一些实用程序类。在JDBC处理过程中抛出的异常被转换为org.springframework.dao包中定义的异常。这意味着使用Spring JDBC抽象层的代码不需要实现JDBC或RDBMS特定的错误处理。所有已翻译的异常都是unchecked的，这使您可以选择捕获可以恢复的异常，同时允许将其他异常传播给调用者。请参阅 [SQLExceptionTranslator](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-SQLExceptionTranslator).

## 3.2 使用JDBC核心类来控制基本的JDBC处理和异常处理

### 3.2.1. JdbcTemplate

JdbcTemplate类是JDBC核心包中的中心类。它处理资源的创建和释放，这可以帮助您避免常见的错误，例如忘记关闭连接。它执行核心JDBC工作流的基本任务，如statement 创建和执行，而应用程序代码负责提供SQL并提取结果。 JdbcTemplate类执行SQL查询，更新和存储过程调用，对ResultSets执行迭代并提取返回的参数值。它还捕获JDBC异常，并将其转换为org.springframework.dao包中定义的通用，更丰富的异常层次结构。

当您使用JdbcTemplate时，您只需要实现回调接口，给他们一个明确定义的实现。 PreparedStatementCreator回调接口根据这个类提供的Connection创建一个prepared statement，提供SQL和任何必要的参数。 CallableStatementCreator接口也是如此，该接口创建可调用语句。 RowCallbackHandler接口从ResultSet的每一行提取值。

JdbcTemplate可以在DAO实现中使用，通过引用一个DataSource，直接实例化一个JdbcTemplate，或者在Spring IoC容器中配置，并作为bean引用提供给DAO。

```
DataSource应始终在Spring IoC容器中配置为一个bean。在第一种情况下，bean直接被提供给服务;在第二种情况下，它被提供给准备好的模板。
```

所有由此类发出的SQL都将在与JdbcTemplate的完全限定类名相对应的类下的目录下，打DEBUG级别的日志（通常为JdbcTemplate，但如果您使用的是JdbcTemplate类的自定义子类，则可能会有所不同）。

#### JdbcTemplate类用法的示例

本节提供了一些JdbcTemplate类用法的示例。这些示例并不是JdbcTemplate公开的所有功能的详尽列表;详细信息请参考javadocs

##### Querying (SELECT)

以下是获取表中行数的简单查询：

```java
int rowCount = this.jdbcTemplate.queryForObject("select count(*) from t_actor", Integer.class);
```

##### 使用绑定变量的简单查询：

```java
int countOfActorsNamedJoe = this.jdbcTemplate.queryForObject(
        "select count(*) from t_actor where first_name = ?", Integer.class, "Joe");
```

##### 查询字符串：

```java
String lastName = this.jdbcTemplate.queryForObject(
        "select last_name from t_actor where id = ?",
        new Object[]{1212L}, String.class);
```

##### 查询和填充单个domain对象：

```java
Actor actor = this.jdbcTemplate.queryForObject(
        "select first_name, last_name from t_actor where id = ?",
        new Object[]{1212L},
        new RowMapper<Actor>() {
            public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
                Actor actor = new Actor();
                actor.setFirstName(rs.getString("first_name"));
                actor.setLastName(rs.getString("last_name"));
                return actor;
            }
        });
```

##### 查询和填充一些domain对象：

```java
List<Actor> actors = this.jdbcTemplate.query(
        "select first_name, last_name from t_actor",
        new RowMapper<Actor>() {
            public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
                Actor actor = new Actor();
                actor.setFirstName(rs.getString("first_name"));
                actor.setLastName(rs.getString("last_name"));
                return actor;
            }
        });
```

如果最后两个代码片段实际上存在于同一个应用程序中，那么删除两个RowMapper匿名内部类中的重复项并将其提取到一个类（通常是一个静态嵌套类）中是有意义的，根据需要由DAO方法引用。例如，最好写一个final的代码片段，如下所示：

```java
public List<Actor> findAllActors() {
    return this.jdbcTemplate.query( "select first_name, last_name from t_actor", new ActorMapper());
}

private static final class ActorMapper implements RowMapper<Actor> {

    public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
        Actor actor = new Actor();
        actor.setFirstName(rs.getString("first_name"));
        actor.setLastName(rs.getString("last_name"));
        return actor;
    }
}
```

##### Updating (INSERT/UPDATE/DELETE) with JdbcTemplate

您使用update（..）方法执行插入，更新和删除操作。参数值通常以var args的形式提供，或者作为对象数组提供。

```java
this.jdbcTemplate.update(
        "insert into t_actor (first_name, last_name) values (?, ?)",
        "Leonor", "Watling");
```

```java
this.jdbcTemplate.update(
        "update t_actor set last_name = ? where id = ?",
        "Banjo", 5276L);
```

```java
this.jdbcTemplate.update(
        "delete from actor where id = ?",
        Long.valueOf(actorId));
```

##### 其他的JdbcTemplate操作

您可以使用execute（..）方法来执行任意SQL，这种方法通常用于DDL语句。它大量地重载了带有回调接口，绑定变量数组等等的变体。

```java
this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
```

以下示例调用一个简单的存储过程。稍后将介绍更复杂的存储过程支持 [covered later](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-StoredProcedure).。

```java
this.jdbcTemplate.update(
        "call SUPPORT.REFRESH_ACTORS_SUMMARY(?)",
        Long.valueOf(unionId));
```

#### JdbcTemplate最佳实践

JdbcTemplate类的实例一旦配置就是线程安全的。这很重要，因为这意味着您可以配置单个JdbcTemplate的实例，然后将此共享引用安全地注入到多个DAO（或repository）中。 JdbcTemplate是有状态的，因为它维护对DataSource的引用，但是这种状态不是会话状态。

当使用JdbcTemplate类（和相关的NamedParameterJdbcTemplate类）时，常见的做法是在Spring配置文件中配置一个DataSource，然后将共享的DataSource bean依赖注入到DAO类中; JdbcTemplate是在DataSource的setter中创建的。这导致DAO看起来部分如下：

```java
public class JdbcCorporateEventDao implements CorporateEventDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    // JDBC-backed implementations of the methods on the CorporateEventDao follow...
}
```

相应的配置可能如下所示。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <bean id="corporateEventDao" class="com.example.JdbcCorporateEventDao">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="${jdbc.driverClassName}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <context:property-placeholder location="jdbc.properties"/>

</beans>
```

显式配置的替代方法是使用组件扫描和注释支持来进行依赖注入。在这种情况下，您使用@Repository注解这个类（这使得它成为组件扫描的候选），并使用@Autowired注释DataSource setter方法。

```java
@Repository
public class JdbcCorporateEventDao implements CorporateEventDao {

    private JdbcTemplate jdbcTemplate;

    @Autowired
    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    // JDBC-backed implementations of the methods on the CorporateEventDao follow...
}
```

相应的XML配置文件如下所示：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <!-- Scans within the base package of the application for @Component classes to configure as beans -->
    <context:component-scan base-package="org.springframework.docs.test" />

    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="${jdbc.driverClassName}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <context:property-placeholder location="jdbc.properties"/>

</beans>
```

如果您使用的是Spring的JdbcDaoSupport类，并且您的各种JDBC支持的DAO类是从中继承的，那么您的子类会从JdbcDaoSupport类继承setDataSource（..）方法。你可以选择是否继承这个类。 JdbcDaoSupport类仅作为便利提供。

无论您选择使用哪种模板初始化样式（或不使用），每次要执行SQL时都很少需要创建JdbcTemplate类的新实例。配置完成后，JdbcTemplate实例就是线程安全的。如果应用程序访问需要多个DataSource的多个数据库，并且随后需要多个不同配置的JdbcTemplates，则可能需要多个JdbcTemplate实例。

### 3.2.2. NamedParameterJdbcTemplate

NamedParameterJdbcTemplate类使用命名参数实现对JDBC语句进行编程的支持，而不是仅使用经典占位符（'？'）参数编程JDBC语句。 NamedParameterJdbcTemplate类包装JdbcTemplate，并委托给包装好的JdbcTemplate来完成大部分工作。本节仅介绍NamedParameterJdbcTemplate类中与JdbcTemplate本身不同的地方;即使用命名参数对JDBC语句进行编程。

```java
// some JDBC-backed DAO class...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(*) from T_ACTOR where first_name = :first_name";

    SqlParameterSource namedParameters = new MapSqlParameterSource("first_name", firstName);

    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}
```

请注意，在赋给sql变量的值中使用了命名参数表示法，并且赋给sql变量的值，由namedParameters变量（MapSqlParameterSource类型）表示。

或者，可以使用基于map的样式将命名参数及其对应的值传递给NamedParameterJdbcTemplate实例。由NamedParameterJdbcOperations暴露并由NamedParameterJdbcTemplate类实现的其余方法遵循类似的模式，在此不予介绍。

以下示例显示了使用基于map的样式。

```java
// some JDBC-backed DAO class...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(*) from T_ACTOR where first_name = :first_name";

    Map<String, String> namedParameters = Collections.singletonMap("first_name", firstName);

    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters,  Integer.class);
}
```

与NamedParameterJdbcTemplate相关的一个很好的功能是SqlParameterSource接口（并存在于同一个Java包中）。您已经在前面的一个代码片段（MapSqlParameterSource类）中看到了一个实现此接口的示例。 SqlParameterSource是NamedParameterJdbcTemplate的命名参数值的来源。 MapSqlParameterSource类是一个非常简单的实现，它只是一个包装java.util.Map的适配器，其中键是参数名，值是参数值。

另一个SqlParameterSource实现是BeanPropertySqlParameterSource类。这个类包装了一个任意的JavaBean（也就是符合 [the JavaBean conventions](http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html)的一个类的一个实例），并且使用被包装的JavaBean的属性作为命名参数值的来源。

```java
public class Actor {

    private Long id;
    private String firstName;
    private String lastName;

    public String getFirstName() {
        return this.firstName;
    }

    public String getLastName() {
        return this.lastName;
    }

    public Long getId() {
        return this.id;
    }

    // setters omitted...

}
```

```java
// some JDBC-backed DAO class...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActors(Actor exampleActor) {

    // notice how the named parameters match the properties of the above 'Actor' class
    String sql = "select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName";

    SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);

    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}
```

请记住，NamedParameterJdbcTemplate类包装了经典的JdbcTemplate模板;如果您需要访问包装的JdbcTemplate实例以访问仅存在于JdbcTemplate类中的功能，则可以使用getJdbcOperations（）方法通过JdbcOperations接口访问包装的JdbcTemplate。

有关在应用程序的上下文中使用NamedParameterJdbcTemplate类的准则，另请参阅[JdbcTemplate best practices](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-JdbcTemplate-idioms)。

### 3.2.3. SQLExceptionTranslator

SQLExceptionTranslator是一个接口，实现类可以在SQLException和Spring自己的org.springframework.dao.DataAccessException之间进行转换，这在数据访问策略方面是不可知的。实现可以是通用的（例如，使用JDBC的SQLState codes）或专有的（例如，使用Oracl eerror codes）以获得更高的精度。

SQLErrorCodeSQLExceptionTranslator是默认使用的SQLExceptionTranslator的实现。该实现使用特定的供应商code。它比SQLState实现更精确。错误代码转换基于JavaBean类型类（称为SQLErrorCodes）中保存的代码。这个类由SQLErrorCodesFactory创建和填充，顾名思义，它是一个用于根据名为sql-error-codes.xml的配置文件的内容创建SQLErrorCodes的工厂。该文件由供应商code填充，而且是基于从DatabaseMetaData获取的DatabaseProductName生成的。改文件中的最终的codes使用您正在使用的实际数据库的code。

SQLErrorCodeSQLExceptionTranslator按照以下顺序应用匹配规则：

```
SQLErrorCodesFactory默认用于定义错误代码和自定义异常转换。在classpath中查找它们，名称为sql-error-codes.xml，匹配的SQLErrorCodes实例根据所使用数据库的数据库元数据中的数据库名称定位。
```

- Any custom translation implemented by a subclass. Normally the provided concrete`SQLErrorCodeSQLExceptionTranslator` is used so this rule does not apply. It only applies if you have actually provided a subclass implementation.
- Any custom implementation of the `SQLExceptionTranslator` interface that is provided as the `customSqlExceptionTranslator` property of the `SQLErrorCodes` class.
- The list of instances of the `CustomSQLErrorCodesTranslation` class, provided for the `customTranslations` property of the `SQLErrorCodes` class, are searched for a match.
- Error code matching is applied.
- Use the fallback translator. `SQLExceptionSubclassTranslator` is the default fallback translator. If this translation is not available then the next fallback translator is the `SQLStateSQLExceptionTranslator`.

您可以继承SQLErrorCodeSQLExceptionTranslator：

```java
public class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {

    protected DataAccessException customTranslate(String task, String sql, SQLException sqlex) {
        if (sqlex.getErrorCode() == -12345) {
            return new DeadlockLoserDataAccessException(task, sqlex);
        }
        return null;
    }
}
```

在这个例子中，特定的错误代码-12345被翻译，并且其他错误由默认的翻译器实现来翻译。要使用此自定义转换程序，必须通过setExceptionTranslator方法将其传递给JdbcTemplate，并将此JdbcTemplate用于需要此转换程序的所有数据访问处理。这里是一个如何使用这个自定义翻译器的例子：

```java
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {

    // create a JdbcTemplate and set data source
    this.jdbcTemplate = new JdbcTemplate();
    this.jdbcTemplate.setDataSource(dataSource);

    // create a custom translator and set the DataSource for the default translation lookup
    CustomSQLErrorCodesTranslator tr = new CustomSQLErrorCodesTranslator();
    tr.setDataSource(dataSource);
    this.jdbcTemplate.setExceptionTranslator(tr);

}

public void updateShippingCharge(long orderId, long pct) {
    // use the prepared JdbcTemplate for this update
    this.jdbcTemplate.update("update orders" +
        " set shipping_charge = shipping_charge * ? / 100" +
        " where id = ?", pct, orderId);
}
```

自定义翻译器被传递一个数据源，以便在sql-error-codes.xml中查找错误代码。

### 3.2.4. Executing statements

执行一条SQL语句只需要很少的代码。您需要一个DataSource和一个JdbcTemplate，包括JdbcTemplate提供的便捷方法。下面的例子显示了你需要的最少代码但功能齐全的类来创建一个新表：

```java
import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAStatement {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void doExecute() {
        this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
    }
}
```

### 3.2.5. Running queries

一些查询方法返回一个值。要从一行检索计数或特定值，请使用queryForObject（..）。后者将返回的JDBC类型转换为作为参数传入的Java类。如果类型转换无效，则引发InvalidDataAccessApiUsageException异常。下面是一个包含两个查询方法的例子，一个用于int，一个用于查询String。

```java
import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class RunAQuery {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int getCount() {
        return this.jdbcTemplate.queryForObject("select count(*) from mytable", Integer.class);
    }

    public String getName() {
        return this.jdbcTemplate.queryForObject("select name from mytable", String.class);
    }
}
```

除了单个结果查询方法之外，还有几个方法返回一个列表，其中包含查询返回的每一行的条目。最通用的方法是queryForList（..），它返回一个List，其中每个条目都是一个Map，map中的每个条目代表该行的列值。如果您在上面的示例中添加一个方法来检索所有行的列表，它将如下所示：

```java
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
}

public List<Map<String, Object>> getList() {
    return this.jdbcTemplate.queryForList("select * from mytable");
}
```

返回的列表看起来像这样：

```
[{name=Bob, id=1}, {name=Mary, id=2}]
```

### 3.2.6. Updating the database

以下示例显示了为某个主键更新的列。在此示例中，SQL语句具有行参数的占位符。参数值可以作为可变参数传递，也可以作为一个对象数组传递。因此，基元应该被包装在基本的包装类中，或者使用自动装箱。

```java
import javax.sql.DataSource;

import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAnUpdate {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public Spring通过一个DataSource获取到数据库的连接。 DataSource是JDBC规范的一部分，是一个通用的连接工厂。它允许容器或框架隐藏应用程序代码中的连接池和事务管理问题。作为一名开发人员，您不需要知道如何连接到数据库;这是设置数据源的管理员的责任。在开发和测试代码时，您最有可能同时担任这两个角色，但您不一定必须知道生产数据源是如何配置的。void setName(int id, String name) {
        this.jdbcTemplate.update("update mytable set name = ? where id = ?", name, id);
    }
}
```

### 3.2.7. Retrieving auto-generated keys

update（）便捷方法支持检索由数据库生成的主键。这种支持是JDBC 3.0标准的一部分;细节见第13.6章。该方法将PreparedStatementCreator作为其第一个参数，这个参数指定了所需的插入语句。另一个参数是KeyHolder，它包含从更新成功返回时生成的主键。没有一种标准的简单方法来创建适当的PreparedStatement（这解释了为什么方法签名是这样的）。以下示例适用于Oracle，但可能不适用于其他平台：

```java
final String INSERT_SQL = "insert into my_test (name) values(?)";
final String name = "Rob";

KeyHolder keyHolder = new GeneratedKeyHolder();
jdbcTemplate.update(
    new PreparedStatementCreator() {
        public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
            PreparedStatement ps = connection.prepareStatement(INSERT_SQL, new String[] {"id"});
            ps.setString(1, name);
            return ps;
        }
    },
    keyHolder);

// keyHolder.getKey() now contains the generated key
```

## 3.3 控制数据库连接

### 3.3.1. DataSource

Spring通过一个DataSource获取到数据库的连接。 DataSource是JDBC规范的一部分，是一个通用的连接工厂。它允许容器或框架隐藏应用程序代码中的连接池和事务管理问题。作为一名开发人员，您不需要知道如何连接到数据库;这是设置数据源的管理员的责任。在开发和测试代码时，您最有可能同时担任这两个角色，但您不一定必须知道生产数据源是如何配置的。

当使用Spring的JDBC层时，您从JNDI获得数据源，或者使用第三方提供的连接池实现来配置自己的数据源。流行的实现是Apache Jakarta Commons DBCP和C3P0。 Spring发行版中的实现仅用于测试目的，不提供连接池功能。

本节使用Spring的DriverManagerDataSource实现，稍后将介绍其他一些实现。

```
DriverManagerDataSource类应该仅用于测试目的，因为它不提供池，并且会在执行多个连接请求时性能下降。
```

您通常会从DriverManagerDataSource获得连接，就好像你自己拥有一个连接一样。指定JDBC驱动程序的全限定类名，以便DriverManager可以加载驱动程序类。接下来，提供一个和JDBC驱动程序对应的数据源URL。 （请查阅驱动程序的文档以获取正确的值。）然后提供用户名和密码以连接到数据库。以下是如何在Java代码中配置DriverManagerDataSource的示例：

```java
DriverManagerDataSource dataSource = new DriverManagerDataSource();
dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
dataSource.setUrl("jdbc:hsqldb:hsql://localhost:");
dataSource.setUsername("sa");
dataSource.setPassword("");
```

下面是相应的XML配置：

```xml
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
    <property name="driverClassName" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>

<context:property-placeholder location="jdbc.properties"/>
```

以下示例显示了DBCP和C3P0的基本连接和配置。要了解更多有助于控制池功能的选项，请参阅各个连接池的产品文档。

DBCP配置：

```xml
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>

<context:property-placeholder location="jdbc.properties"/>
```

C3P0配置：

```xml
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close">
    <property name="driverClass" value="${jdbc.driverClassName}"/>
    <property name="jdbcUrl" value="${jdbc.url}"/>
    <property name="user" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>

<context:property-placeholder location="jdbc.properties"/>
```

### 3.3.2. DataSourceUtils

DataSourceUtils类是一个方便且功能强大的帮助类，它提供静态方法来获取来自JNDI的连接，并在必要时关闭连接。它支持与例如DataSourceTransactionManager的线程绑定连接。

### 3.3.3. SmartDataSource

SmartDataSource接口的实现以提供到关系数据库的连接。它扩展了DataSource接口，允许使用它的类查询连接是否应该在给定的操作之后关闭。当您知道您将重用连接时，此用法是有效的。

### 3.3.4. AbstractDataSource

AbstractDataSource是Spring的DataSource实现的一个抽象基类，它实现了所有DataSource实现通用的代码。如果您正在编写自己的DataSource实现，则扩展AbstractDataSource类。

### 3.3.5. SingleConnectionDataSource

SingleConnectionDataSource类是SmartDataSource接口的一个实现，它包装了每次使用后都没有关闭的单个Connection。显然，这不具备多线程能力。

如果任何客户端代码假设调用一个连接池管理的连接的close方法，就像在使用持久性工具时一样，请将suppressClose属性设置为true。此设置将返回包装物理连接的抑制关闭的代理。请注意，您将无法将其转换为原生的Oracle Connection或类似的东西。

这主要是一个测试类。例如，它可以轻松测试应用程序服务器之外的代码以及简单的JNDI环境。与DriverManagerDataSource相反，它始终重复使用相同的连接，避免过度创建物理连接。

### 3.3.6. DriverManagerDataSource

DriverManagerDataSource类是通过bean属性配置普通JDBC驱动程序的标准DataSource接口的实现，并且每次都返回一个新的Connection。

此实现对于Java EE容器之外的测试和独立环境很有用，可以是Spring IoC容器中的DataSource bean，也可以是简单的JNDI环境。 Pool-假设Connection.close（）调用将简单地关闭连接，所以任何`DataSource`-aware的持久性代码都可以工作。但是，即使在测试环境中，使用JavaBean样式的连接池（如commons-dbcp）也非常容易，因此和DriverManagerDataSource相比推荐使用连接池。

### 3.3.7. TransactionAwareDataSourceProxy

TransactionAwareDataSourceProxy是目标DataSource的代理，它封装了目标DataSource以使目标DataSource能感知spring的事务。在这方面，它类似于由Java EE服务器提供的事务性JNDI数据源。

除非已经存在的代码必须被调用并通过一个标准的JDBC DataSource接口实现，否则使用这个类是很不可取的。在这种情况下，仍然有可能使这个代码可用，同时这个代码参与Spring管理事务。通常最好使用更高级别的资源管理抽象（如JdbcTemplate或DataSourceUtils）编写自己的新代码。

（有关更多详细信息，请参阅TransactionAwareDataSourceProxy javadocs。）

### 3.3.8. DataSourceTransactionManager

DataSourceTransactionManager类是简单JDBC数据源的PlatformTransactionManager实现。它将JDBC连接从指定的数据源绑定到当前正在执行的线程，允许每个数据源一个线程连接。

应用程序代码需要通过DataSourceUtils.getConnection（DataSource）来检索JDBC连接，而不是Java EE的标准DataSource.getConnection。因为使用DataSourceUtils会抛出未经检查的org.springframework.dao异常而不是checked的SQLExceptions。像JdbcTemplate这样的所有框架类都隐式地使用这个策略。如果不使用这个事务管理器，查找策略的行为就像普通的一样 - 因此可以在任何情况下使用。

DataSourceTransactionManager类支持自定义的隔离级别和超时，它以适当的方式获取JDBC语句查询timeout。为了支持后者，应用程序代码必须使用JdbcTemplate或为每个创建的语句调用DataSourceUtils.applyTransactionTimeout（..）方法。

这个实现可以用来代替JtaTransactionManager，在单个资源的情况下，因为它不需要容器来支持JTA。如果您坚持所需的连接查找模式，两者之间的切换只是一个配置问题。 JTA不支持自定义隔离级别！

## 3.4  JDBC批处理操作

如果您将对同一个 prepared statement调用多次，则大多数JDBC驱动程序都会通过将update分组执行以限制往返数据库的次数提高性能。

### 3.4.1 使用JdbcTemplate进行基本批量操作

通过实现特殊接口BatchPreparedStatementSetter的两个方法，并将其作为batchUpdate方法调用中的第二个参数传入，从而完成JdbcTemplate批处理。使用getBatchSize方法提供当前批次的大小。使用setValues方法设置准备语句的参数值。这个方法将被调用getBatchSize方法中指定的次数。以下示例根据列表中的条目更新actor表。整个列表在这个例子中被用作批处理：

```java
public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[] batchUpdate(final List<Actor> actors) {
        return this.jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                new BatchPreparedStatementSetter() {
                    public void setValues(PreparedStatement ps, int i) throws SQLException {
                        ps.setString(1, actors.get(i).getFirstName());
                        ps.setString(2, actors.get(i).getLastName());
                        ps.setLong(3, actors.get(i).getId().longValue());
                    }
                    public int getBatchSize() {
                        return actors.size();
                    }
                });
    }

    // ... additional methods
}
```

如果您正在处理更新流或从文件中读取数据，那么您可能有一个预设置的批处理大小，但最后一批可能没有这个数目的条目。在这种情况下，您可以使用InterruptibleBatchPreparedStatementSetter接口，该接口允许您在输入源耗尽后中断批处理。 isBatchExhausted方法允许您发出批次结束的信号。

### 3.4.2. Batch operations with a List of objects

JdbcTemplate和NamedParameterJdbcTemplate都提供了提供批量更新的备用方法。你提供的所有参数值在列表中，而不是像上节一样实现一个特殊的批处理接口。框架遍历这些值并使用内部准备好的statement setter。 API根据您是否使用named parameters会有所不同。对于named parameters，您提供了一个SqlParameterSource数组，每个批处理成员都有一个条目。您可以使用SqlParameterSourceUtils.createBatch便捷方法创建此数组，并传入一个bean样式的对象（与参数对应的getter方法）和/或String-keyed Maps（包含相应参数作为值）的数组。

这个例子显示了使用命名参数的批量更新：

```java
public class JdbcActorDao implements ActorDao {

    private NamedParameterTemplate namedParameterJdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
    }

    public int[] batchUpdate(List<Actor> actors) {
        return this.namedParameterJdbcTemplate.batchUpdate(
                "update t_actor set first_name = :firstName, last_name = :lastName where id = :id",
                SqlParameterSourceUtils.createBatch(actors));
    }

    // ... additional methods
}
```

对于使用经典“？”的SQL语句占位符，您将传递一个包含具有更新值的对象数组的列表。此对象数组必须对于SQL语句中的每个占位符都有一个条目，并且它们的顺序必须与SQL语句中定义的顺序相同。

使用经典JDBC“？”占位符的相同例子：

```java
public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[] batchUpdate(final List<Actor> actors) {
        List<Object[]> batch = new ArrayList<Object[]>();
        for (Actor actor : actors) {
            Object[] values = new Object[] {
                    actor.getFirstName(), actor.getLastName(), actor.getId()};
            batch.add(values);
        }
        return this.jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                batch);
    }

    // ... additional methods
}
```

上述所有批处理更新方法都会返回一个int数组，其中包含每个批处理条目的受影响行数。这个计数由JDBC驱动程序报告。如果count不可用，则JDBC驱动程序返回a -2 。

```
在底层PreparedStatement上自动设置值的情况下，每个值的相应JDBC类型需要从给定的Java类型派生。虽然这通常运作良好，但存在潜在的问题，例如参数Map中包含null：在这种情况下，Spring将默认调用ParameterMetaData.getParameterType，这对您的JDBC驱动程序来说可能是昂贵的。请确保使用最新的驱动程序版本，并考虑将“spring.jdbc.getParameterType.ignore”属性设置为“true”（作为JVM系统属性或在类路径根目录的spring.properties文件中）遇到性能问题，例如正如Oracle 12c（SPR-16139）所报告的那样。
或者，只要考虑明确地指定相应的JDBC类型即可：或者通过上面显示的“BatchPreparedStatementSetter”，或者通过给定的基于List * Object []>的调用或通过调用显式类型数组'MapSqlParameterSource'实例的registerSqlType方法，或者通过'BeanPropertySqlParameterSource'即使对于null值，也可以从Java声明的属性类型派生SQL类型。
```

### 3.4.3. Batch operations with multiple batches

批量更新的最后一个例子处理的是特别大的批次，以至于要将其分成几个较小的批次。你当然可以通过多次调用batchUpdate方法来完成上述方法，但现在有一个更方便的方法。除SQL语句外，此方法还包含一个包含参数的对象集合，每个批次的更新次数以及一个ParameterizedPreparedStatementSetter，用于设置prepared statement的参数值。框架循环提供的值并将更新调用分成指定大小的批处理。

此示例显示使用批量大小为100的批量更新：

```java
public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[][] batchUpdate(final Collection<Actor> actors) {
        int[][] updateCounts = jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                actors,
                100,
                new ParameterizedPreparedStatementSetter<Actor>() {
                    public void setValues(PreparedStatement ps, Actor argument) throws SQLException {
                        ps.setString(1, argument.getFirstName());
                        ps.setString(2, argument.getLastName());
                        ps.setLong(3, argument.getId().longValue());
                    }
                });
        return updateCounts;
    }

    // ... additional methods
}
```

此调用的批处理更新方法返回一个int二维数组，其中包含每次批处理中每条更新语句影响的行数。顶级数组的长度表示执行的批次数，第二级数组的长度表示该批次中的更新数。

## 3.5 使用SimpleJdbc类简化JDBC操作

SimpleJdbcInsert和SimpleJdbcCall类通过JDBC驱动程序检索的数据库元数据来提供简化的配置。但如果您希望在代码中提供所有详细信息，则可以覆盖或关闭元数据处理。

### 3.5.1 使用SimpleJdbcInsert插入数据

让我们先看看最少的配置选项的SimpleJdbcInsert类。您应该在数据访问层的初始化方法中实例化SimpleJdbcInsert。对于这个例子，初始化方法是setDataSource方法。您不需要继承SimpleJdbcInsert类;只需创建一个新的实例并使用withTableName方法设置数据库表名。这个类的配置方法遵循返回SimpleJdbcInsert实例的“流体”风格，它允许链接所有的配置方法。本示例只使用一种配置方法;稍后您会看到多个示例。

```java
public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.insertActor = new SimpleJdbcInsert(dataSource).withTableName("t_actor");
    }

    public void add(Actor actor) {
        Map<String, Object> parameters = new HashMap<String, Object>(3);
        parameters.put("id", actor.getId());
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        insertActor.execute(parameters);
    }

    // ... additional methods
}
```

这里的execute方法使用普通的java.utils.Map作为唯一的参数。这里要注意的重点是用于Map的键必须与数据库中定义的表的列名相匹配。这是因为我们读取元数据以构建实际的插入语句。

### 3.5.2 使用SimpleJdbcInsert检索自动生成的主键

此示例使用与前面相同的插入语句，但不是传入id，而是检索自动生成的键，并将其设置在新的Actor对象上。当您创建SimpleJdbcInsert时，除了指定表名之外，还可以使用usingGeneratedKeyColumns方法指定生成的键列的名称。

```java
public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        Map<String, Object> parameters = new HashMap<String, Object>(2);
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    // ... additional methods
}
```

通过第二种方法执行插入操作的主要区别在于，您不需要将该ID添加到Map中，而是调用executeAndReturnKey方法。这将返回一个java.lang.Number对象，您可以使用该对象创建在我们的domain类中使用的数字类型的实例。你不能依赖所有的数据库在这里返回一个特定的Java类; java.lang.Number是你可以依赖的基类。如果您有多个自动生成的列，或者生成的值是非数字值，则可以使用从executeAndReturnKeyHolder方法返回的KeyHolder。

### 3.5.3 为SimpleJdbcInsert指定操作的列

您可以通过使用usingColumns方法指定列名称列表来限制插入的列：

```java
public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingColumns("first_name", "last_name")
                .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        Map<String, Object> parameters = new HashMap<String, Object>(2);
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    // ... additional methods
}
```

插入的执行与依靠元数据来确定要使用哪些列相同。

### 3.5.4 使用SqlParameterSource提供参数值

使用Map来提供参数值可以正常工作，但它不是最方便的类。 Spring提供了几个SqlParameterSource接口的实现，可以用来代替。第一个是BeanPropertySqlParameterSource，如果你有一个包含插入的值的JavaBean的类，BeanPropertySqlParameterSource是一个非常方便的类。它将使用相应的getter方法来提取参数值。这里是一个例子：

```java
public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor);
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    // ... additional methods
}
```

另一个参数类是类似于Map的MapSqlParameterSource，但提供了一个更方便的addValue方法，可以链接设置值。

```java
public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        SqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("first_name", actor.getFirstName())
                .addValue("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    // ... additional methods
}
```

正如你所看到的，配置是一样的;只有执行代码必须更改为使用这些替代输入类。

### 3.5.5 使用SimpleJdbcCall调用存储过程

SimpleJdbcCall类利用数据库中的元数据来查找输入和输出参数的名称，以便您不必显式声明它们。如果您喜欢这样做，则可以声明参数，或者如果您有诸如ARRAY或STRUCT之类的参数没有自动映射到Java类的参数。第一个例子展示了一个简单的存储过程，它只从MySQL数据库返回VARCHAR和DATE格式的标量值。示例过程读取指定的actor项，并以out参数的形式返回first_name，last_name和birth_date列。

```mysql
CREATE PROCEDURE read_actor (
    IN in_id INTEGER,
    OUT out_first_name VARCHAR(100),
    OUT out_last_name VARCHAR(100),
    OUT out_birth_date DATE)
BEGIN
    SELECT first_name, last_name, birth_date
    INTO out_first_name, out_last_name, out_birth_date
    FROM t_actor where id = in_id;
END;
```

in_id参数包含您正在查找的actor的id。 out参数返回从表中读取的数据。

SimpleJdbcCall的声明方式与SimpleJdbcInsert相似。您应该在数据访问层的初始化方法中实例化和配置类。与StoredProcedure类相比，您不必创建子类，也不必声明可在数据库元数据中查找的参数。以下是使用上述存储过程的SimpleJdbcCall配置示例。除了DataSource之外，唯一的配置选项是存储过程的名称。

```java
public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.procReadActor = new SimpleJdbcCall(dataSource)
                .withProcedureName("read_actor");
    }

    public Actor readActor(Long id) {
        SqlParameterSource in = new MapSqlParameterSource()
                .addValue("in_id", id);
        Map out = procReadActor.execute(in);
        Actor actor = new Actor();
        actor.setId(id);
        actor.setFirstName((String) out.get("out_first_name"));
        actor.setLastName((String) out.get("out_last_name"));
        actor.setBirthDate((Date) out.get("out_birth_date"));
        return actor;
    }

    // ... additional methods
}
```

您为执行存储过程而编写的代码涉及创建一个包含IN参数的SqlParameterSource。为输入值提供的名称与在存储过程中声明的参数名进行匹配非常重要。大小写不必匹配，因为您使用元数据来确定如何在存储过程中引用数据库对象。存储过程源中指定的内容不一定是存储在数据库中的方式。某些数据库将名称转换为全部大写，而其他数据库则使用小写或使用指定的大小写。

execute方法使用IN参数，并返回一个包含由存储过程中指定的名称所键入的任何out参数的Map。在这种情况下，它们是out_first_name，out_last_name和out_birth_date。

execute方法的最后一部分创建一个Actor实例，用于返回检索的数据。同样，重要的是使用存储过程中声明的out参数的名称。此外，结果map中存储的输出参数的名称与数据库中输出参数名称的大小写是否相匹配，这可能因数据库而异。为了使你的代码更加具有可移植性，你应该做一个不区分大小写的查找，或者指示Spring使用LinkedCaseInsensitiveMap。要使用后者，你创建你自己的JdbcTemplate并设置setResultsMapCaseInsensitive属性为true。然后你将这个定制的JdbcTemplate实例传递给你的SimpleJdbcCall的构造函数。这是这个配置的一个例子：

```java
public class JdbcActorDao implements ActorDao {

    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadActor = new SimpleJdbcCall(jdbcTemplate)
                .withProcedureName("read_actor");
    }

    // ... additional methods
}
```

通过执行此操作，可避免因返回参数名称不匹配而引起的冲突。

### 3.5.6 显式声明用于SimpleJdbcCall的参数

你已经看到参数是如何根据元数据推导出来的，但是如果你愿意，你可以明确地声明。您可以通过使用declareParameters方法创建和配置SimpleJdbcCall来完成此操作，该方法将可变数量的SqlParameter对象作为输入。有关如何定义SqlParameter的详细信息，请参阅下一节。

```
如果您使用的数据库不是Spring支持的数据库，则显式声明是必需的。目前，Spring支持以下数据库的存储过程调用的元数据查找：Apache Derby，DB2，MySQL，Microsoft SQL Server，Oracle和Sybase。我们还支持MySQL，Microsoft SQL Server和Oracle的存储函数的元数据查找。
```

您可以选择明确声明一个，一些或全部参数。参数元数据仍然在没有显式声明参数的地方使用。要绕过可能参数的元数据查找的所有处理，并仅使用声明的参数，则可以将方法withoutProcedureColumnMetaDataAccess作为声明的一部分进行调用。假设您为数据库函数声明了两个或多个不同的调用参数。在这种情况下，您可以调用useInParameterNames来指定要包含给定签名的IN参数名称的列表。

以下示例使用前面的示例中的信息演示完全声明的过程调用。

```java
public class JdbcActorDao implements ActorDao {

    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadActor = new SimpleJdbcCall(jdbcTemplate)
                .withProcedureName("read_actor")
                .withoutProcedureColumnMetaDataAccess()
                .useInParameterNames("in_id")
                .declareParameters(
                        new SqlParameter("in_id", Types.NUMERIC),
                        new SqlOutParameter("out_first_name", Types.VARCHAR),
                        new SqlOutParameter("out_last_name", Types.VARCHAR),
                        new SqlOutParameter("out_birth_date", Types.DATE)
                );
    }

    // ... additional methods
}
```

这两个例子的执行和结果是一样的，这个明确地指定了所有的细节，而不是依靠元数据。

### 3.5.7 如何定义SqlParameters

要为SimpleJdbc类以及RDBMS([Modeling JDBC operations as Java objects](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-object))操作类定义一个参数，您可以使用SqlParameter或它的一个子类。您通常在构造函数中指定参数名称和SQL类型。 SQL类型是使用java.sql.Types常量指定的。我们已经看到如下声明：

```java
new SqlParameter("in_id", Types.NUMERIC),
    new SqlOutParameter("out_first_name", Types.VARCHAR),
```

SqlParameter的第一行声明了一个IN参数。 IN参数既可以用于存储过程调用，也可以用于使用下一节中介绍的SqlQuery及其子类的查询。

SqlOutParameter的第二行声明了一个在存储过程调用中使用的out参数。还有一个用于InOut参数的SqlInOutParameter参数，它为过程提供一个IN值，同时返回一个值。

```
只有声明为SqlParameter和SqlInOutParameter的参数将被用来提供输入值。这与StoredProcedure类不同，后者出于向下兼容性的原因允许为声明为SqlOutParameter的参数提供输入值。
```

对于IN参数，除了名称和SQL类型外，还可以为numeric 数据指定精度或为自定义数据库类型指定类型名称。对于out参数，可以提供RowMapper来处理从REF游标返回的row的映射。另一种选择是指定一个SqlReturnType，它提供了定义返回值的自定义处理的机会。

### 3.5.8 用SimpleJdbcCall调用存储的函数

除了提供函数名称而不是过程名称之外，您可以像调用存储过程一样调用存储函数。您可以使用withFunctionName方法作为配置的一部分，以指示我们要调用一个函数，并为函数调用生成相应的字符串。一个专门的执行调用executeFunction被用来执行这个函数，它将函数返回值作为一个指定类型的对象返回，这意味着你不必从resultMap中检索返回值。名为executeObject的类似的便捷方法也适用于只有一个out参数的存储过程。以下示例基于名为get_actor_name的存储函数，该函数返回一个actor的全名。这里是这个函数的MySQL源代码：

```mysql
CREATE FUNCTION get_actor_name (in_id INTEGER)
RETURNS VARCHAR(200) READS SQL DATA
BEGIN
    DECLARE out_name VARCHAR(200);
    SELECT concat(first_name, ' ', last_name)
        INTO out_name
        FROM t_actor where id = in_id;
    RETURN out_name;
END;
```

要调用这个函数，我们再次在初始化方法中创建一个SimpleJdbcCall。

```java
public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcCall funcGetActorName;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.funcGetActorName = new SimpleJdbcCall(jdbcTemplate)
                .withFunctionName("get_actor_name");
    }

    public String getActorName(Long id) {
        SqlParameterSource in = new MapSqlParameterSource()
                .addValue("in_id", id);
        String name = funcGetActorName.executeFunction(String.class, in);
        return name;
    }

    // ... additional methods
}
```

使用的execute方法返回一个包含函数调用返回值的String。

### 3.5.9 从SimpleJdbcCall中返回ResultSet / REF游标

调用返回结果集的存储过程或函数有点棘手。某些数据库在JDBC结果处理期间返回结果集，而其他数据库则需要显式注册特定类型的参数。这两种方式都需要额外的处理来遍历结果集并处理返回的行。通过 ，您可以使用returningResultSet方法并声明RowMapper实现用于特定参数。在结果处理期间返回结果集的情况下，没有定义名称，所以返回的结果必须与声明RowMapper实现的顺序相匹配。指定的名称仍用于将处理的结果列表存储在从execute语句返回的结果映射中。

下一个示例使用不包含IN参数的存储过程，并返回t_actor表中的所有行。以下是此过程的MySQL源代码：

```mysql
CREATE PROCEDURE read_all_actors()
BEGIN
 SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a;
END;
```

要调用此过程，请声明RowMapper。因为要映射的类遵循JavaBean规则，所以可以使用通过传入所需类来映射到newInstance方法创建的BeanPropertyRowMapper。

```java
public class JdbcActorDao implements ActorDao {

    private SimpleJdbcCall procReadAllActors;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadAllActors = new SimpleJdbcCall(jdbcTemplate)
                .withProcedureName("read_all_actors")
                .returningResultSet("actors",
                BeanPropertyRowMapper.newInstance(Actor.class));
    }

    public List getActorsList() {
        Map m = procReadAllActors.execute(new HashMap<String, Object>(0));
        return (List) m.get("actors");
    }
```

执行调用传入一个空的map，因为这个调用没有任何输入参数。然后从结果map中检索Actor列表并返回给调用者。

## 3.6 将JDBC操作建模为Java对象

略

## 3.7 参数和数据值处理的常见问题

### 3.7.1. Providing SQL type information for parameters

### 3.7.2. Handling BLOB and CLOB objects

### 3.7.3. Passing in lists of values for IN clause

### 3.7.4. Handling complex types for stored procedure calls

## 3.8 嵌入式数据库支持

org.springframework.jdbc.datasource.embedded包提供对嵌入式Java数据库引擎的支持。天然提供对 [HSQL](http://www.hsqldb.org/), [H2](http://www.h2database.com/)和[Derby](https://db.apache.org/derby) 的支持。您还可以使用可扩展的API来插入新的嵌入式数据库类型和数据源实现。

### 3.8.1 为什么使用嵌入式数据库？

嵌入式数据库在项目的开发阶段非常有用，因为它具有轻量级特性。好处包括配置简单，启动时间快，可测试性强，并且能够在开发过程中快速修改SQL。

### 3.8.2 使用Spring XML创建一个嵌入式数据库

如果您想在Spring ApplicationContext中将嵌入式数据库实例暴露为一个bean，请在spring-jdbc命名空间中使用embedded-database标签：

```xml
<jdbc:embedded-database id="dataSource" generate-name="true">
    <jdbc:script location="classpath:schema.sql"/>
    <jdbc:script location="classpath:test-data.sql"/>
</jdbc:embedded-database>
```

上述配置创建了一个嵌入式HSQL数据库，该数据库使用schema.sql中的SQL和classpath根目录下的test-data.sql资源填充。此外，作为最佳实践，嵌入式数据库将被分配一个唯一生成的名称。嵌入式数据库作为一个javax.sql.DataSource类型的bean被Spring容器使用，然后可以根据需要将其注入到数据访问对象中。

上述配置创建了一个嵌入式HSQL数据库，该数据库使用schema.sql中的SQL和classpath根目录下的test-data.sql资源填充。此外，作为最佳实践，嵌入式数据库将被分配一个唯一生成的名称。嵌入式数据库作为一个javax.sql.DataSource类型的bean被Spring容器使用，然后可以根据需要将其注入到dao中。

### 3.8.3 以编程方式创建嵌入式数据库

EmbeddedDatabaseBuilder类提供了一个流畅的API来以编程方式构建嵌入式数据库。当您需要在独立环境或独立集成测试中创建嵌入式数据库时，请使用此方法，如下例所示。

```java
EmbeddedDatabase db = new EmbeddedDatabaseBuilder()
        .generateUniqueName(true)
        .setType(H2)
        .setScriptEncoding("UTF-8")
        .ignoreFailedDrops(true)
        .addScript("schema.sql")
        .addScripts("user_data.sql", "country_data.sql")
        .build();

// perform actions against the db (EmbeddedDatabase extends javax.sql.DataSource)

db.shutdown()
```

有关所有支持的选项的更多详细信息，请参阅EmbeddedDatabaseBuilder的Javadoc。

EmbeddedDatabaseBuilder也可用于使用Java Config创建嵌入式数据库，如下例所示。

```java
@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
                .generateUniqueName(true)
                .setType(H2)
                .setScriptEncoding("UTF-8")
                .ignoreFailedDrops(true)
                .addScript("schema.sql")
                .addScripts("user_data.sql", "country_data.sql")
                .build();
    }
}
```

### 3.8.4 选择嵌入的数据库类型

#### Using HSQL

Spring支持HSQL 1.8.0及以上版本。如果没有明确指定类型，HSQL是默认的嵌入式数据库。要显式指定HSQL，请将embedded-database标签的type属性设置为HSQL。如果您正在使用构建器API，请使用EmbeddedDatabaseType.HSQL调用setType（EmbeddedDatabaseType）方法。

#### Using H2

Spring也支持H2数据库。要启用H2，请将embedded-database标记的type属性设置为H2。如果您正在使用构建器API，请使用EmbeddedDatabaseType.H2调用setType（EmbeddedDatabaseType）方法。

#### Using Derby

Spring还支持Apache Derby 10.5及更高版本。要启用Derby，请将embedded-database标记的type属性设置为DERBY。如果您正在使用构建器API，请使用EmbeddedDatabaseType.DERBY调用setType（EmbeddedDatabaseType）方法。

### 3.8.5 用嵌入式数据库测试数据访问逻辑

嵌入式数据库提供了测试数据访问代码的轻量级方法。以下是使用嵌入式数据库的数据访问集成测试的模板。如果嵌入式数据库不需要跨测试类重用，那么使用这样的模板对于一次性使用是有用的。但是，如果您希望创建一个在测试套件中共享的嵌入式数据库，请考虑使用 [Spring TestContext Framework](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/testing.html#testcontext-framework)并在Spring ApplicationContext中将嵌入式数据库配置为一个bean，如 [Creating an embedded database using Spring XML](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-embedded-database-xml)或 [Creating an embedded database programmatically](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-embedded-database-java).。

```java
public class DataAccessIntegrationTestTemplate {

    private EmbeddedDatabase db;

    @Before
    public void setUp() {
        // creates an HSQL in-memory database populated from default scripts
        // classpath:schema.sql and classpath:data.sql
        db = new EmbeddedDatabaseBuilder()
                .generateUniqueName(true)
                .addDefaultScripts()
                .build();
    }

    @Test
    public void testDataAccess() {
        JdbcTemplate template = new JdbcTemplate(db);
        template.query( /* ... */ );
    }

    @After
    public void tearDown() {
        db.shutdown();
    }

}
```

### 3.8.6 为嵌入式数据库生成唯一的名称

如果开发团队的测试套件无意中尝试重新创建同一数据库的其他实例，则经常会遇到嵌入式数据库的错误。如果XML配置文件或@Configuration类负责创建嵌入式数据库，并且相应的配置在相同测试套件中的多个测试场景（即，在相同的JVM进程内）之间重复使用，则这可以非常容易地发生 - 例如，针对嵌入式数据库的集成测试，数据库ApplicationContext配置仅随着不同的bean定义配置文件被激活而不同。

这种错误的根本原因在于Spring的EmbeddedDatabaseFactory（由<jdbc：embedded-database> XML名称空间元素和EmbeddedDatabaseBuilder for Java Config内部使用）会将嵌入式数据库的名称设置为“testdb”，除非明确指定了数据库的名称。对于<jdbc：embedded-database>的情况，嵌入式数据库通常被赋予一个与bean的id相同的名称（即通常类似于“dataSource”）。因此，随后尝试创建嵌入式数据库不会产生新的数据库。相反，将重用相同的JDBC连接URL，尝试创建新的嵌入式数据库实际上会指向使用相同配置创建的现有嵌入式数据库。

为了解决这个常见问题，Spring Framework 4.2提供了为嵌入式数据库生成唯一名称的支持。要启用生成的名称，请使用以下选项之一。

- `EmbeddedDatabaseFactory.setGenerateUniqueDatabaseName()`
- `EmbeddedDatabaseBuilder.generateUniqueName()`
- `<jdbc:embedded-database generate-name="true" … >`

### 3.8.7 扩展嵌入式数据库支持

Spring JDBC嵌入式数据库支持可以通过两种方式进行扩展：

- 实现EmbeddedDatabaseConfigurer以支持新的嵌入式数据库类型。
- 实现DataSourceFactory以支持新的DataSource实现，例如连接池来管理嵌入式数据库连接。

我们鼓励您在 [jira.spring.io](https://jira.spring.io/browse/SPR).上向Spring社区提供扩展。

## 3.9 初始化一个DataSource

org.springframework.jdbc.datasource.init包为初始化现有的DataSource提供支持。嵌入式数据库支持为应用程序创建和初始化嵌入式DataSource提供了一个选项，但有时您需要初始化在某个服务器上运行的数据库实例。

### 3.9.1 使用Spring XML初始化数据库

如果要初始化数据库，并且可以提供对DataSource bean的引用，请在spring-jdbc名称空间中使用initialize-database标签：

```xml
<jdbc:initialize-database data-source="dataSource">
    <jdbc:script location="classpath:com/foo/sql/db-schema.sql"/>
    <jdbc:script location="classpath:com/foo/sql/db-test-data.sql"/>
</jdbc:initialize-database>
```

上面的例子执行了针对数据库指定的两个脚本：第一个脚本创建一个schema，第二个脚本使用测试数据集填充表。脚本位置也可以是在Spring中用于资源的常用ant风格（如classpath *：/ com / foo / ** / sql / *  -  data.sql）中带有通配符的模式。如果使用这种模式，则脚本按其URL或文件名的词法顺序执行。

数据库初始化程序的默认行为是无条件执行提供的脚本。例如，如果您正在针对已经包含测试数据的数据库执行脚本，则这并不总是您想要的。意外删除数据的可能性通过遵循先创建表格然后插入数据的常见模式（如上所示）来减少 - 如果表格已经存在，第一步将失败。

但是，为了更好地控制现有数据的创建和删除，XML名称空间提供了一些其他选项。第一个是打开和关闭初始化标志。这可以根据环境来设置（例如，从系统属性或环境bean中提取布尔值），例如：

```xml
<jdbc:initialize-database data-source="dataSource"
    enabled="#{systemProperties.INITIALIZE_DATABASE}">
    <jdbc:script location="..."/>
</jdbc:initialize-database>
```

控制现有数据的第二个选择是容错性。为此，您可以控制初始化程序忽略从脚本执行的SQL中的某些错误的能力，例如：

```xml
<jdbc:initialize-database data-source="dataSource" ignore-failures="DROPS">
    <jdbc:script location="..."/>
</jdbc:initialize-database>
```

在这个例子中，我们假设我们期望有时脚本将在一个空的数据库中被执行，并且在脚本中有一些DROP语句，因此会失败。所以失败的SQL DROP语句将被忽略，但其他失败将导致异常。如果您的SQL方言不支持DROP ... IF EXISTS（或类似的），但您希望在重新创建之前无条件地删除所有测试数据，那么这非常有用。在这种情况下，第一个脚本通常是一组DROP语句，随后是一组CREATE语句。

ignore-failures选项可以设置为NONE（默认），DROPS（忽略失败的丢弃）或ALL（忽略所有失败）。

每个语句应该被分开，使用;分隔，或者每个语句占一个新的行。您可以全局范围或脚本范围内控制分隔符，例如：

```xml
<jdbc:initialize-database data-source="dataSource" separator="@@">
    <jdbc:script location="classpath:com/foo/sql/db-schema.sql" separator=";"/>
    <jdbc:script location="classpath:com/foo/sql/db-test-data-1.sql"/>
    <jdbc:script location="classpath:com/foo/sql/db-test-data-2.sql"/>
</jdbc:initialize-database>
```

在这个例子中，两个测试数据脚本使用@@作为语句分隔符，只有db-schema.sql使用;。此配置指定默认分隔符是@@，db-schema脚本的默认分隔符覆盖全局分隔符@@。

如果您需要比XML名称空间更多的控制，则可以直接使用DataSourceInitializer，并将其定义为应用程序中的组件。

#### 初始化依赖于数据库的其他组件

一大类应用程序可以使用数据库初始化程序，而不会有其他复杂情况：那些在Spring上下文启动之前不使用数据库的应用程序。如果您的应用程序不是其中之一，那么您可能需要阅读本节的其余部分。

略

# 4. Object Relational Mapping (ORM) Data Access

## 4.1. Introduction to ORM with Spring

Spring框架支持与 Java Persistence API （JPA）以及本地Hibernate（用于资源管理，数据访问对象（DAO）实现和事务策略）的集成。例如，对于Hibernate来说，有一些便利的IoC功能可以解决许多典型的Hibernate集成问题。您可以通过依赖注入为O / R（对象关系）映射工具配置所有支持的功能。他们可以参与Spring的资源和事务管理，并遵守Spring的通用事务和DAO异常层次结构。建议的集成风格是对纯朴的Hibernate或JPA API进行DAO编码。

当您创建数据访问应用程序时，Spring会为您选择的ORM层添加显着的增强功能。您可以根据需要尽可能多地利用集成支持，并且应该将此集成工作与构建类似基础架构的成本和风险相比较。不管使用什么技术，您都可以像使用库一样使用大部分的ORM支持，因为所有东西都被设计成一组可重用的JavaBean。 Spring IoC容器中的ORM便于配置和部署。因此本节中的大多数示例都显示了Spring容器内的配置。

使用Spring框架创建ORM DAO的好处包括：

更简单的测试。 Spring的IoC方式可以轻松地更换Hibernate SessionFactory实例，JDBC DataSource实例，事务管理器和映射对象实现（如果需要）的实现和配置位置。这反过来又使得单独测试每个与持久性相关的代码变得更容易。

常见的数据访问异常。 Spring可以封装ORM工具中的异常，将它们从专有的（可能被检查的）异常转换为公共的运行时DataAccessException层次结构。这个特性允许你处理大多数不可恢复的持久性异常，可以在适当的层次上进行处理，而不用编写烦人的抛出和处理异常声明的样板代码。您仍然可以根据需要捕获和处理异常。请记住，JDBC异常（包括特定于数据库的方言）也会转换为相同的异常层次结构，这意味着您可以在一致的编程模型中使用JDBC执行一些操作。

通用资源管理。 Spring应用程序上下文可以处理Hibernate SessionFactory实例，JPA EntityManagerFactory实例，JDBC DataSource实例和其他相关资源的位置和配置。这使得这些值易于管理和更改。 Spring提供持久性资源的有效，简单和安全的处理。例如，使用Hibernate的相关代码通常需要使用相同的Hibernate Session来确保效率和正确的事务处理。Spring通过Hibernate SessionFactory公开当前Session，Spring可以很容易地透明地创建Session并将其绑定到当前线程。因此，Spring解决了许多典型Hibernate使用的慢性问题，适用于任何本地或JTA事务环境。

集成事务管理。您可以通过@Transactional注释或通过在XML配置文件中显式配置事务AOP通知，来使用声明性的面向方面编程（AOP）风格的方法拦截器来包装ORM代码。在这两种情况下，都会为您处理事务语义和异常处理（回滚等）。如下所述，在 [Resource and transaction management](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#orm-resource-mngmnt)中，您还可以交换各种事务管理器，而不会影响与您的ORM相关的代码。例如，您可以在本地事务和JTA之间进行交换，在这两种情况下可以使用相同的完整服务（例如声明性事务）。此外，与JDBC相关的代码可以与您用于执行ORM的代码完全集成。这对于不适合于ORM的数据访问非常有用，例如批处理和BLOB流式传输，它们仍然需要与ORM操作共享公共事务。

要获得更全面的ORM支持（包括对MongoDB等替代数据库技术的支持），您可能需要查看[Spring Data](https://projects.spring.io/spring-data/) 项目套件。如果您是JPA用户，那么https://spring.io中的“ [Getting Started Accessing Data with JPA](https://spring.io/guides/gs/accessing-data-jpa/) ”指南提供了一个很好的介绍。

## 4.2 一般ORM集成注意事项

略

## 4.3. Hibernate

略

## 4.4. JPA

略

# 5. Marshalling XML using O/X Mappers

## 5.1 介绍

在本章中，我们将介绍Spring的Object/ XML映射支持。Object/ XML映射（简称O / X映射）是将XML文档转换为对象的操作。这个转换过程也被称为XML Marshalling 或XML序列化。本章可以互换使用这些术语。

在O / X映射领域，*marshaller* 负责将对象（图）序列化为XML。以类似的方式，*unmarshaller* 将XML反序列化为对象。这个XML可以是DOM文档，输入或输出流或SAX handler的形式。

为使用Spring的的O / X映射的一些好处是：

### 5.1.1 易于配置

Spring的bean工厂可以很容易地配置marshallers，而不需要构建JAXB上下文，JiBX绑定工厂等等。marshailer可以配置为应用上下文中的任何其他bean。另外，基于XML命名空间的配置可用于一些marshallers，使配置更简单。

### 5.1.2 一致的接口

Spring的O / X映射通过两个全局接口操作：Marshaller和Unmarshaller接口。这些抽象使您可以相对容易地切换O / X映射框架，而在进行*marshaller* 的类中几乎不需要任何更改。这种方法还有另外一个好处，就是可以混合使用不同的实现（例如，使用JAXB执行一些*marshaller* ，而其他使用Castor的*marshaller* ）以非侵入性的方式进行XML *marshaller* ，这是利用每种技术的优势。

### 5.1.3 一致的异常层次结构

Spring将异常从底层的O / X映射工具转换为它自己的异常层次结构，其中XmlMappingException作为根异常。正如所期望的那样，这些运行时异常包装了原始异常，所以没有信息丢失。

## 5.2. Marshaller and Unmarshaller

正如介绍中所述，Marshaller 将对象序列化为XML，Unmarshaller将XML流反序列化为对象。在本节中，我们将介绍用于此目的的两个Spring接口。

### 5.2.1. Marshaller

Spring的org.springframework.oxm.Marshaller包抽象所有Marshaller操作，主要方法如下所示。

```java
public interface Marshaller {

    /**
     * Marshal the object graph with the given root into the provided Result.
     */
    void marshal(Object graph, Result result) throws XmlMappingException, IOException;
}
```

Marshaller接口有一个主要方法，它将给定对象编组到给定的javax.xml.transform.Result。Result是基本的表示XML输出抽象的标记接口：具体实现包装各种XML表示，如下表所示。

| Result implementation | Wraps XML representation                 |
| --------------------- | ---------------------------------------- |
| `DOMResult`           | `org.w3c.dom.Node`                       |
| `SAXResult`           | `org.xml.sax.ContentHandler`             |
| `StreamResult`        | `java.io.File`, `java.io.OutputStream`, or `java.io.Writer` |

```
尽管marshal（）方法接受一个普通对象作为其第一个参数，但大多数Marshaller实现不能处理任意对象。相反，一个对象类必须被映射到一个映射文件中，标记有一个注解，在编组器中注册，或者拥有一个公共基类。请参阅本章的其他部分，以确定您的O / X技术如何管理这个。
```

### 5.2.2. Unmarshaller

与Marshaller类似，还有org.springframework.oxm.Unmarshaller接口。

```java
public interface Unmarshaller {

    /**
     * Unmarshal the given provided Source into an object graph.
     */
    Object unmarshal(Source source) throws XmlMappingException, IOException;
}
```

这个接口也有一个方法，它从给定的javax.xml.transform.Source（一个XML输入抽象）中读取数据，并返回读取的对象。和Result一样，Source是一个标记接口，有三个具体的实现。每个包装一个不同的XML表示，如下表所示。

| Source implementation | Wraps XML representation                 |
| --------------------- | ---------------------------------------- |
| `DOMSource`           | `org.w3c.dom.Node`                       |
| `SAXSource`           | `org.xml.sax.InputSource`, and `org.xml.sax.XMLReader` |
| `StreamSource`        | `java.io.File`, `java.io.InputStream`, or `java.io.Reader` |

即虽然有两个单独的编组接口（Marshaller和Unmarshaller），但Spring-WS中的所有实现都在一个类中实现。这意味着你可以连接一个marshaller类，并在你的applicationContext.xml中把它作为一个Marshaller和Unmarshaller

### 5.2.3. XmlMappingException

Spring将异常从底层O / X映射工具转换为自己的异常层次结构，并将XmlMappingException作为根异常。可以预料的是，这些运行时异常包装了原始异常，所以不会丢失任何信息。

此外，虽然底层的O / X映射工具不这样做，但MarshallingFailureException和UnmarshallingFailureException提供了marshalling and unmarshalling 操作之间的区别。

O / X映射异常层次结构如下图所示：

![https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/images/oxm-exceptions.png]()

### 5.3 使用Marshaller和Unmarshaller

Spring的OXM可以用于各种各样的情况。在以下示例中，我们将使用它将Spring管理的application的settings编组为XML文件。我们将使用一个简单的JavaBean来表示settings：

```java
public class Settings {

    private boolean fooEnabled;

    public boolean isFooEnabled() {
        return fooEnabled;
    }

    public void setFooEnabled(boolean fooEnabled) {
        this.fooEnabled = fooEnabled;
    }
}
```

应用程序类使用这个bean来存储它的设置。除了一个主要的方法外，这个类有两个方法：saveSettings（）将设置bean保存到一个名为settings.xml的文件中，loadSettings（）再次加载这些设置。 main（）方法构造一个Spring应用程序上下文，并调用这两个方法。

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.oxm.Marshaller;
import org.springframework.oxm.Unmarshaller;

public class Application {

    private static final String FILE_NAME = "settings.xml";
    private Settings settings = new Settings();
    private Marshaller marshaller;
    private Unmarshaller unmarshaller;

    public void setMarshaller(Marshaller marshaller) {
        this.marshaller = marshaller;
    }

    public void setUnmarshaller(Unmarshaller unmarshaller) {
        this.unmarshaller = unmarshaller;
    }

    public void saveSettings() throws IOException {
        FileOutputStream os = null;
        try {
            os = new FileOutputStream(FILE_NAME);
            this.marshaller.marshal(settings, new StreamResult(os));
        } finally {
            if (os != null) {
                os.close();
            }
        }
    }

    public void loadSettings() throws IOException {
        FileInputStream is = null;
        try {
            is = new FileInputStream(FILE_NAME);
            this.settings = (Settings) this.unmarshaller.unmarshal(new StreamSource(is));
        } finally {
            if (is != null) {
                is.close();
            }
        }
    }

    public static void main(String[] args) throws IOException {
        ApplicationContext appContext =
                new ClassPathXmlApplicationContext("applicationContext.xml");
        Application application = (Application) appContext.getBean("application");
        application.saveSettings();
        application.loadSettings();
    }
}
```

应用程序需要设置 `marshaller` and `unmarshaller`。我们可以使用下面的applicationContext.xml来做到这一点：

```xml
<beans>
    <bean id="application" class="Application">
        <property name="marshaller" ref="castorMarshaller" />
        <property name="unmarshaller" ref="castorMarshaller" />
    </bean>
    <bean id="castorMarshaller" class="org.springframework.oxm.castor.CastorMarshaller"/>
</beans>
```

这个应用程序上下文使用了Castor，但我们可以使用本章后面介绍的其他编组实例。请注意，Castor默认情况下不需要任何进一步的配置，所以bean定义相当简单。另请注意，CastorMarshaller实现了Marshaller和Unmarshaller，所以我们可以在应用程序的marshaller和unmarshaller属性中引用同一个castorMarshaller bean。

此示例应用程序生成以下settings.xml文件：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<settings foo-enabled="false"/>
```

## 5.4 XML配置名称空间

Marshailer可以使用OXM名称空间中的标签进行更简洁的配置。为了使这些标签可用，必须首先在XML配置文件的前导码中引用适当的schema。请注意下面的'oxm'相关文字：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:oxm="http://www.springframework.org/schema/oxm" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd *http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm.xsd"*>
```

目前，以下标签可用：

- [`jaxb2-marshaller`](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#oxm-jaxb2-xsd)
- [`jibx-marshaller`](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#oxm-jibx-xsd)
- [`castor-marshaller`](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#oxm-castor-xsd)

每个标签将在各自的编组部分进行解释。举个例子，下面是JAXB2编组器的配置：

```xml
<oxm:jaxb2-marshaller id="marshaller" contextPath="org.springframework.ws.samples.airline.schema"/>
```

## 5.5. JAXB

JAXB绑定编译器将W3C XML Schema转换为一个或多个Java类，jaxb.properties文件以及可能的一些资源文件。 JAXB还提供了一种从注释的Java类生成schema的方法。

Spring支持JAXB 2.0 API作为XML编组策略，遵循 [Marshaller and Unmarshaller](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#oxm-marshaller-unmarshaller)中描述的Marshaller和Unmarshaller接口。相应的集成类位于org.springframework.oxm.jaxb包中。

### 5.5.1. Jaxb2Marshaller

Jaxb2Marshaller类实现了Spring Marshaller和Unmarshaller接口。它需要一个上下文路径来操作，你可以使用contextPath属性来设置。上下文路径是包含schema派生类的以冒号（:)分隔的Java包名称的列表。它还提供了一个classesToBeBound属性，它允许你设置一个由marshaller支持的类的数组。schema验证通过指定一个或多个schema资源到bean来执行，如下所示：

```xml
<beans>
    <bean id="jaxb2Marshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller">
        <property name="classesToBeBound">
            <list>
                <value>org.springframework.oxm.jaxb.Flight</value>
                <value>org.springframework.oxm.jaxb.Flights</value>
            </list>
        </property>
        <property name="schema" value="classpath:org/springframework/oxm/schema.xsd"/>
    </bean>

    ...

</beans>
```

#### XML配置名称空间

jaxb2-marshaller标签配置一个org.springframework.oxm.jaxb.Jaxb2Marshaller。这里是一个例子：

```xml
<oxm:jaxb2-marshaller id="marshaller" contextPath="org.springframework.ws.samples.airline.schema"/>
```

另外，要绑定的类列表可以通过待class-to-be-bound子标签提供给编组：

```xml
<oxm:jaxb2-marshaller id="marshaller">
    <oxm:class-to-be-bound name="org.springframework.ws.samples.airline.schema.Airport"/>
    <oxm:class-to-be-bound name="org.springframework.ws.samples.airline.schema.Flight"/>
    ...
</oxm:jaxb2-marshaller>
```

可用的属性是：

| Attribute     | Description              | Required |
| ------------- | ------------------------ | -------- |
| `id`          | the id of the marshaller | no       |
| `contextPath` | the JAXB Context path    | no       |

## 5.6. Castor

Castor XML映射是一个开源的XML绑定框架。它允许您将包含在Java对象模型中的数据转换成XML文档。默认情况下，不需要任何进一步的配置，虽然映射文件可以用来更好地控制Castor的行为。

有关Castor的更多信息，请参阅[*Castor web site*](https://castor-data-binding.github.io/castor).。 Spring集成类位于org.springframework.oxm.castor包中。

### 5.6.1. CastorMarshaller

和JAXB一样，CastorMarshaller实现了Marshaller和Unmarshaller接口。它可以被配置如下：

```xml
<beans>
    <bean id="castorMarshaller" class="org.springframework.oxm.castor.CastorMarshaller" />
    ...
</beans>
```

### 5.6.2. Mapping

虽然可以依赖Castor的默认编组行为，但可能需要对其进行更多的控制。这可以使用Castor映射文件来完成。有关更多信息，请参阅 [Castor XML Mapping](https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/index.html#xml.mapping)。

映射可以使用mappingLocation资源属性进行设置，如下面的classpath资源所示。

```xml
<beans>
    <bean id="castorMarshaller" class="org.springframework.oxm.castor.CastorMarshaller" >
        <property name="mappingLocation" value="classpath:mapping.xml" />
    </bean>
</beans>
```

#### XML configuration namespace

castor-marshaller标签配置一个org.springframework.oxm.castor.CastorMarshaller。这里是一个例子：

```xml
<oxm:castor-marshaller id="marshaller" mapping-location="classpath:org/springframework/oxm/castor/mapping.xml"/>
```

编组实例可以通过两种方式进行配置：指定映射文件的位置（通过mapping-location属性），或者通过标识存在相应对象的Java POJO（通过`target-class` or `target-package`属性） XML描述符类。后一种方式通常与XML schema中的XML代码生成结合使用。

可用的属性是：

| Attribute          | Description                              | Required |
| ------------------ | ---------------------------------------- | -------- |
| `id`               | the id of the marshaller                 | no       |
| `encoding`         | the encoding to use for unmarshalling from XML | no       |
| `target-class`     | a Java class name for a POJO for which an XML class descriptor is available (as generated through code generation) | no       |
| `target-package`   | a Java package name that identifies a package that contains POJOs and their corresponding Castor XML descriptor classes (as generated through code generation from XML schemas) | no       |
| `mapping-location` | location of a Castor XML mapping file    | no       |

## 5.7. JiBX

略

## 5.8. XStream

略

# 6.附录

## 6.1. XML Schemas

附录的这一部分列出了用于数据访问的XML schema。

### 6.1.1. The `tx` schema

tx标签处理在Spring对事务的全面支持中配置所有这些bean。这些标签在[Transaction Management](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#transaction)一章中介绍。

```
强烈建议您查看Spring发行版附带的“spring-tx.xsd”文件。这个文件（当然）是Spring的事务配置的XML Schema，涵盖了tx命名空间中的所有标签，包括属性defaults等。这个文件是内联记录的，因此这里不再重复这些信息是为了坚持 DRY （不重复自己）的原则。
```

为了完整起见，要在tx schema中使用标签，您需要在Spring XML配置文件的顶部有以下前导码;以下代码段中的文本引用了正确的模式，以便tx名称空间中的标记可供您使用。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"> <!-- bean definitions here -->

</beans>
```

```
经常在TX命名空间中使用标签时，你也将使用来自AOP命名空间中的标签（因为Spring中的声明式事务使用AOP实现）。上面的XML片段包含引用aop模式所需的相关行，以便aop命名空间中的标签可供您使用。
```

### 6.1.2. The `jdbc` schema

jdbc标签允许您快速配置嵌入式数据库或初始化现有的数据源。这些标签分别记录在 [Embedded database support](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-embedded-database-support)和 [Initializing a DataSource](https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/data-access.html#jdbc-initializing-datasource)中。

要在jdbc schema中使用标签，您需要在Spring XML配置文件的顶部有以下前导码;以下代码片段中的文本引用了正确的schema，以便jdbc命名空间中的标签可供您使用。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd"> <!-- bean definitions here -->

</beans>
```

